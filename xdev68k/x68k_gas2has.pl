#!/usr/bin/perl
#------------------------------------------------------------------------------
#
#	x68k_gas2has
#
#	JP:
# 		m68k-elf-gcc が生成した asm ソースを、HAS.X (X68K High-speed Assembler
#		by Y.Nakamura(YuNK) 氏) および HAS060.X (68060 拡張 by M.Kamada 氏) が
#		処理できる形式に変換します。
#
#	EN:
#		This is a converter translates asm sources generated by m68k-elf-gcc
#		into a format that processible by HAS.X (X68K High-Speed Assembler by
#		Y.Nakamura(YuNK)) and HAS060.X (68060 extended by M.Kamada).
#
#------------------------------------------------------------------------------
#
#	Copyright (C) 2022 Yosshin(@yosshin4004)
#
#	Licensed under the Apache License, Version 2.0 (the "License");
#	you may not use this file except in compliance with the License.
#	You may obtain a copy of the License at
#
#	    http://www.apache.org/licenses/LICENSE-2.0
#
#	Unless required by applicable law or agreed to in writing, software
#	distributed under the License is distributed on an "AS IS" BASIS,
#	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#	See the License for the specific language governing permissions and
#	limitations under the License.
#
#------------------------------------------------------------------------------

# コーディングを厳格化
use strict;

# 使用するモジュール
use IO::File;
use Data::Dumper;

# 定数の定義
use constant {
    EXIT_SUCCESS	=> 0,
    EXIT_FAILURE	=> 1,
	DEBUG	 		=> 0,	# 0 or 1
};

# エラーメッセージに含ませるソースの位置情報
my $g_src_location;

# アセンブラモード一覧
my @g_asm_modes = ('gas', 'has');

# シンボルデータベース
my %g_symbol_db;

# MIT syntax → Motorola syntax 変換
my %g_translate_mit_to_motorola = (
	# 例外対応
	'movb'=>'move.b',
	'movw'=>'move.w',
	'movl'=>'move.l',

	# 以下、規則に従って自動生成
	'abcdb'=>'abcd.b','addal'=>'adda.l','addaw'=>'adda.w','addb'=>'add.b',
	'addib'=>'addi.b','addil'=>'addi.l','addiw'=>'addi.w','addl'=>'add.l',
	'addqb'=>'addq.b','addql'=>'addq.l','addqw'=>'addq.w','addw'=>'add.w',
	'addxb'=>'addx.b','addxl'=>'addx.l','addxw'=>'addx.w','andb'=>'and.b',
	'andib'=>'andi.b','andil'=>'andi.l','andiw'=>'andi.w','andl'=>'and.l',
	'andw'=>'and.w','aslb'=>'asl.b','asll'=>'asl.l','aslw'=>'asl.w',
	'asrb'=>'asr.b','asrl'=>'asr.l','asrw'=>'asr.w','bccl'=>'bcc.l',
	'bccs'=>'bcc.s','bccw'=>'bcc.w','bchgb'=>'bchg.b','bchgl'=>'bchg.l',
	'bclrb'=>'bclr.b','bclrl'=>'bclr.l','bcsl'=>'bcs.l','bcss'=>'bcs.s',
	'bcsw'=>'bcs.w','beql'=>'beq.l','beqs'=>'beq.s','beqw'=>'beq.w',
	'bgel'=>'bge.l','bges'=>'bge.s','bgew'=>'bge.w','bgtl'=>'bgt.l',
	'bgts'=>'bgt.s','bgtw'=>'bgt.w','bhil'=>'bhi.l','bhis'=>'bhi.s',
	'bhiw'=>'bhi.w','bhsl'=>'bhs.l','bhss'=>'bhs.s','bhsw'=>'bhs.w',
	'bitrevl'=>'bitrev.l','blel'=>'ble.l','bles'=>'ble.s','blew'=>'ble.w',
	'blol'=>'blo.l','blos'=>'blo.s','blow'=>'blo.w','blsl'=>'bls.l',
	'blss'=>'bls.s','blsw'=>'bls.w','bltl'=>'blt.l','blts'=>'blt.s',
	'bltw'=>'blt.w','bmil'=>'bmi.l','bmis'=>'bmi.s','bmiw'=>'bmi.w',
	'bnccl'=>'bncc.l','bnccs'=>'bncc.s','bnccw'=>'bncc.w','bncsl'=>'bncs.l',
	'bncss'=>'bncs.s','bncsw'=>'bncs.w','bnel'=>'bne.l','bneql'=>'bneq.l',
	'bneqs'=>'bneq.s','bneqw'=>'bneq.w','bnes'=>'bne.s','bnew'=>'bne.w',
	'bngel'=>'bnge.l','bnges'=>'bnge.s','bngew'=>'bnge.w','bngtl'=>'bngt.l',
	'bngts'=>'bngt.s','bngtw'=>'bngt.w','bnhil'=>'bnhi.l','bnhis'=>'bnhi.s',
	'bnhiw'=>'bnhi.w','bnhsl'=>'bnhs.l','bnhss'=>'bnhs.s','bnhsw'=>'bnhs.w',
	'bnlel'=>'bnle.l','bnles'=>'bnle.s','bnlew'=>'bnle.w','bnlol'=>'bnlo.l',
	'bnlos'=>'bnlo.s','bnlow'=>'bnlo.w','bnlsl'=>'bnls.l','bnlss'=>'bnls.s',
	'bnlsw'=>'bnls.w','bnltl'=>'bnlt.l','bnlts'=>'bnlt.s','bnltw'=>'bnlt.w',
	'bnmil'=>'bnmi.l','bnmis'=>'bnmi.s','bnmiw'=>'bnmi.w','bnnel'=>'bnne.l',
	'bnnes'=>'bnne.s','bnnew'=>'bnne.w','bnnzl'=>'bnnz.l','bnnzs'=>'bnnz.s',
	'bnnzw'=>'bnnz.w','bnpll'=>'bnpl.l','bnpls'=>'bnpl.s','bnplw'=>'bnpl.w',
	'bnvcl'=>'bnvc.l','bnvcs'=>'bnvc.s','bnvcw'=>'bnvc.w','bnvsl'=>'bnvs.l',
	'bnvss'=>'bnvs.s','bnvsw'=>'bnvs.w','bnzel'=>'bnze.l','bnzes'=>'bnze.s',
	'bnzew'=>'bnze.w','bnzl'=>'bnz.l','bnzs'=>'bnz.s','bnzw'=>'bnz.w',
	'bpll'=>'bpl.l','bpls'=>'bpl.s','bplw'=>'bpl.w','bral'=>'bra.l',
	'bras'=>'bra.s','braw'=>'bra.w','bsetb'=>'bset.b','bsetl'=>'bset.l',
	'bsrl'=>'bsr.l','bsrs'=>'bsr.s','bsrw'=>'bsr.w','btstb'=>'btst.b',
	'btstl'=>'btst.l','bvcl'=>'bvc.l','bvcs'=>'bvc.s','bvcw'=>'bvc.w',
	'bvsl'=>'bvs.l','bvss'=>'bvs.s','bvsw'=>'bvs.w','byterevl'=>'byterev.l',
	'bzel'=>'bze.l','bzes'=>'bze.s','bzew'=>'bze.w','cas2l'=>'cas2.l',
	'cas2w'=>'cas2.w','casb'=>'cas.b','casl'=>'cas.l','casw'=>'cas.w',
	'chk2b'=>'chk2.b','chk2l'=>'chk2.l','chk2w'=>'chk2.w','chkl'=>'chk.l',
	'chkw'=>'chk.w','clrb'=>'clr.b','clrl'=>'clr.l','clrw'=>'clr.w',
	'cmp2b'=>'cmp2.b','cmp2l'=>'cmp2.l','cmp2w'=>'cmp2.w','cmpal'=>'cmpa.l',
	'cmpaw'=>'cmpa.w','cmpb'=>'cmp.b','cmpib'=>'cmpi.b','cmpil'=>'cmpi.l',
	'cmpiw'=>'cmpi.w','cmpl'=>'cmp.l','cmpmb'=>'cmpm.b','cmpml'=>'cmpm.l',
	'cmpmw'=>'cmpm.w','cmpw'=>'cmp.w','dbccw'=>'dbcc.w','dbcsw'=>'dbcs.w',
	'dbeqw'=>'dbeq.w','dbfw'=>'dbf.w','dbgew'=>'dbge.w','dbgtw'=>'dbgt.w',
	'dbhiw'=>'dbhi.w','dbhsw'=>'dbhs.w','dblew'=>'dble.w','dblow'=>'dblo.w',
	'dblsw'=>'dbls.w','dbltw'=>'dblt.w','dbmiw'=>'dbmi.w','dbnccw'=>'dbncc.w',
	'dbncsw'=>'dbncs.w','dbneqw'=>'dbneq.w','dbnew'=>'dbne.w','dbnfw'=>'dbnf.w',
	'dbngew'=>'dbnge.w','dbngtw'=>'dbngt.w','dbnhiw'=>'dbnhi.w',
	'dbnhsw'=>'dbnhs.w','dbnlew'=>'dbnle.w','dbnlow'=>'dbnlo.w',
	'dbnlsw'=>'dbnls.w','dbnltw'=>'dbnlt.w','dbnmiw'=>'dbnmi.w',
	'dbnnew'=>'dbnne.w','dbnnzw'=>'dbnnz.w','dbnplw'=>'dbnpl.w','dbntw'=>'dbnt.w',
	'dbnvcw'=>'dbnvc.w','dbnvsw'=>'dbnvs.w','dbnzew'=>'dbnze.w','dbnzw'=>'dbnz.w',
	'dbplw'=>'dbpl.w','dbraw'=>'dbra.w','dbtw'=>'dbt.w','dbvcw'=>'dbvc.w',
	'dbvsw'=>'dbvs.w','dbzew'=>'dbze.w','decb'=>'dec.b','decl'=>'dec.l',
	'decw'=>'dec.w','divsl'=>'divs.l','divsll'=>'divsl.l','divsw'=>'divs.w',
	'divul'=>'divu.l','divull'=>'divul.l','divuw'=>'divu.w','eorb'=>'eor.b',
	'eorib'=>'eori.b','eoril'=>'eori.l','eoriw'=>'eori.w','eorl'=>'eor.l',
	'eorw'=>'eor.w','exgl'=>'exg.l','extbl'=>'extb.l','extl'=>'ext.l',
	'extw'=>'ext.w','fabsb'=>'fabs.b','fabsd'=>'fabs.d','fabsl'=>'fabs.l',
	'fabsp'=>'fabs.p','fabss'=>'fabs.s','fabsw'=>'fabs.w','fabsx'=>'fabs.x',
	'facosb'=>'facos.b','facosd'=>'facos.d','facosl'=>'facos.l',
	'facosp'=>'facos.p','facoss'=>'facos.s','facosw'=>'facos.w',
	'facosx'=>'facos.x','faddb'=>'fadd.b','faddd'=>'fadd.d','faddl'=>'fadd.l',
	'faddp'=>'fadd.p','fadds'=>'fadd.s','faddw'=>'fadd.w','faddx'=>'fadd.x',
	'fasinb'=>'fasin.b','fasind'=>'fasin.d','fasinl'=>'fasin.l',
	'fasinp'=>'fasin.p','fasins'=>'fasin.s','fasinw'=>'fasin.w',
	'fasinx'=>'fasin.x','fatanb'=>'fatan.b','fatand'=>'fatan.d',
	'fatanhb'=>'fatanh.b','fatanhd'=>'fatanh.d','fatanhl'=>'fatanh.l',
	'fatanhp'=>'fatanh.p','fatanhs'=>'fatanh.s','fatanhw'=>'fatanh.w',
	'fatanhx'=>'fatanh.x','fatanl'=>'fatan.l','fatanp'=>'fatan.p',
	'fatans'=>'fatan.s','fatanw'=>'fatan.w','fatanx'=>'fatan.x','fbeql'=>'fbeq.l',
	'fbeqw'=>'fbeq.w','fbfl'=>'fbf.l','fbfw'=>'fbf.w','fbgel'=>'fbge.l',
	'fbgew'=>'fbge.w','fbglel'=>'fbgle.l','fbglew'=>'fbgle.w','fbgll'=>'fbgl.l',
	'fbglw'=>'fbgl.w','fbgtl'=>'fbgt.l','fbgtw'=>'fbgt.w','fblel'=>'fble.l',
	'fblew'=>'fble.w','fbltl'=>'fblt.l','fbltw'=>'fblt.w','fbnel'=>'fbne.l',
	'fbnew'=>'fbne.w','fbngel'=>'fbnge.l','fbngew'=>'fbnge.w',
	'fbnglel'=>'fbngle.l','fbnglew'=>'fbngle.w','fbngll'=>'fbngl.l',
	'fbnglw'=>'fbngl.w','fbngtl'=>'fbngt.l','fbngtw'=>'fbngt.w',
	'fbnlel'=>'fbnle.l','fbnlew'=>'fbnle.w','fbnltl'=>'fbnlt.l',
	'fbnltw'=>'fbnlt.w','fbogel'=>'fboge.l','fbogew'=>'fboge.w',
	'fbogll'=>'fbogl.l','fboglw'=>'fbogl.w','fbogtl'=>'fbogt.l',
	'fbogtw'=>'fbogt.w','fbolel'=>'fbole.l','fbolew'=>'fbole.w',
	'fboltl'=>'fbolt.l','fboltw'=>'fbolt.w','fborl'=>'fbor.l','fborw'=>'fbor.w',
	'fbral'=>'fbra.l','fbraw'=>'fbra.w','fbseql'=>'fbseq.l','fbseqw'=>'fbseq.w',
	'fbsfl'=>'fbsf.l','fbsfw'=>'fbsf.w','fbsnel'=>'fbsne.l','fbsnew'=>'fbsne.w',
	'fbstl'=>'fbst.l','fbstw'=>'fbst.w','fbtl'=>'fbt.l','fbtw'=>'fbt.w',
	'fbueql'=>'fbueq.l','fbueqw'=>'fbueq.w','fbugel'=>'fbuge.l',
	'fbugew'=>'fbuge.w','fbugtl'=>'fbugt.l','fbugtw'=>'fbugt.w',
	'fbulel'=>'fbule.l','fbulew'=>'fbule.w','fbultl'=>'fbult.l',
	'fbultw'=>'fbult.w','fbunl'=>'fbun.l','fbunw'=>'fbun.w','fcmpb'=>'fcmp.b',
	'fcmpd'=>'fcmp.d','fcmpl'=>'fcmp.l','fcmpp'=>'fcmp.p','fcmps'=>'fcmp.s',
	'fcmpw'=>'fcmp.w','fcmpx'=>'fcmp.x','fcosb'=>'fcos.b','fcosd'=>'fcos.d',
	'fcoshb'=>'fcosh.b','fcoshd'=>'fcosh.d','fcoshl'=>'fcosh.l',
	'fcoshp'=>'fcosh.p','fcoshs'=>'fcosh.s','fcoshw'=>'fcosh.w',
	'fcoshx'=>'fcosh.x','fcosl'=>'fcos.l','fcosp'=>'fcos.p','fcoss'=>'fcos.s',
	'fcosw'=>'fcos.w','fcosx'=>'fcos.x','fdabsb'=>'fdabs.b','fdabsd'=>'fdabs.d',
	'fdabsl'=>'fdabs.l','fdabsp'=>'fdabs.p','fdabss'=>'fdabs.s',
	'fdabsw'=>'fdabs.w','fdabsx'=>'fdabs.x','fdaddb'=>'fdadd.b',
	'fdaddd'=>'fdadd.d','fdaddl'=>'fdadd.l','fdaddp'=>'fdadd.p',
	'fdadds'=>'fdadd.s','fdaddw'=>'fdadd.w','fdaddx'=>'fdadd.x',
	'fddivb'=>'fddiv.b','fddivd'=>'fddiv.d','fddivl'=>'fddiv.l',
	'fddivp'=>'fddiv.p','fddivs'=>'fddiv.s','fddivw'=>'fddiv.w',
	'fddivx'=>'fddiv.x','fdivb'=>'fdiv.b','fdivd'=>'fdiv.d','fdivl'=>'fdiv.l',
	'fdivp'=>'fdiv.p','fdivs'=>'fdiv.s','fdivw'=>'fdiv.w','fdivx'=>'fdiv.x',
	'fdmoveb'=>'fdmove.b','fdmoved'=>'fdmove.d','fdmovel'=>'fdmove.l',
	'fdmovep'=>'fdmove.p','fdmoves'=>'fdmove.s','fdmovew'=>'fdmove.w',
	'fdmovex'=>'fdmove.x','fdmulb'=>'fdmul.b','fdmuld'=>'fdmul.d',
	'fdmull'=>'fdmul.l','fdmulp'=>'fdmul.p','fdmuls'=>'fdmul.s',
	'fdmulw'=>'fdmul.w','fdmulx'=>'fdmul.x','fdnegb'=>'fdneg.b',
	'fdnegd'=>'fdneg.d','fdnegl'=>'fdneg.l','fdnegp'=>'fdneg.p',
	'fdnegs'=>'fdneg.s','fdnegw'=>'fdneg.w','fdnegx'=>'fdneg.x',
	'fdsqrtb'=>'fdsqrt.b','fdsqrtd'=>'fdsqrt.d','fdsqrtl'=>'fdsqrt.l',
	'fdsqrtp'=>'fdsqrt.p','fdsqrts'=>'fdsqrt.s','fdsqrtw'=>'fdsqrt.w',
	'fdsqrtx'=>'fdsqrt.x','fdsubb'=>'fdsub.b','fdsubd'=>'fdsub.d',
	'fdsubl'=>'fdsub.l','fdsubp'=>'fdsub.p','fdsubs'=>'fdsub.s',
	'fdsubw'=>'fdsub.w','fdsubx'=>'fdsub.x','fetoxb'=>'fetox.b',
	'fetoxd'=>'fetox.d','fetoxl'=>'fetox.l','fetoxm1b'=>'fetoxm1.b',
	'fetoxm1d'=>'fetoxm1.d','fetoxm1l'=>'fetoxm1.l','fetoxm1p'=>'fetoxm1.p',
	'fetoxm1s'=>'fetoxm1.s','fetoxm1w'=>'fetoxm1.w','fetoxm1x'=>'fetoxm1.x',
	'fetoxp'=>'fetox.p','fetoxs'=>'fetox.s','fetoxw'=>'fetox.w',
	'fetoxx'=>'fetox.x','ff1l'=>'ff1.l','fgetexpb'=>'fgetexp.b',
	'fgetexpd'=>'fgetexp.d','fgetexpl'=>'fgetexp.l','fgetexpp'=>'fgetexp.p',
	'fgetexps'=>'fgetexp.s','fgetexpw'=>'fgetexp.w','fgetexpx'=>'fgetexp.x',
	'fgetmanb'=>'fgetman.b','fgetmand'=>'fgetman.d','fgetmanl'=>'fgetman.l',
	'fgetmanp'=>'fgetman.p','fgetmans'=>'fgetman.s','fgetmanw'=>'fgetman.w',
	'fgetmanx'=>'fgetman.x','fintb'=>'fint.b','fintd'=>'fint.d','fintl'=>'fint.l',
	'fintp'=>'fint.p','fintrzb'=>'fintrz.b','fintrzd'=>'fintrz.d',
	'fintrzl'=>'fintrz.l','fintrzp'=>'fintrz.p','fintrzs'=>'fintrz.s',
	'fintrzw'=>'fintrz.w','fintrzx'=>'fintrz.x','fints'=>'fint.s',
	'fintw'=>'fint.w','fintx'=>'fint.x','flog10b'=>'flog10.b',
	'flog10d'=>'flog10.d','flog10l'=>'flog10.l','flog10p'=>'flog10.p',
	'flog10s'=>'flog10.s','flog10w'=>'flog10.w','flog10x'=>'flog10.x',
	'flog2b'=>'flog2.b','flog2d'=>'flog2.d','flog2l'=>'flog2.l',
	'flog2p'=>'flog2.p','flog2s'=>'flog2.s','flog2w'=>'flog2.w',
	'flog2x'=>'flog2.x','flognb'=>'flogn.b','flognd'=>'flogn.d',
	'flognl'=>'flogn.l','flognp'=>'flogn.p','flognp1b'=>'flognp1.b',
	'flognp1d'=>'flognp1.d','flognp1l'=>'flognp1.l','flognp1p'=>'flognp1.p',
	'flognp1s'=>'flognp1.s','flognp1w'=>'flognp1.w','flognp1x'=>'flognp1.x',
	'flogns'=>'flogn.s','flognw'=>'flogn.w','flognx'=>'flogn.x','fmodb'=>'fmod.b',
	'fmodd'=>'fmod.d','fmodl'=>'fmod.l','fmodp'=>'fmod.p','fmods'=>'fmod.s',
	'fmodw'=>'fmod.w','fmodx'=>'fmod.x','fmoveb'=>'fmove.b',
	'fmovecrx'=>'fmovecr.x','fmoved'=>'fmove.d','fmovel'=>'fmove.l',
	'fmoveml'=>'fmovem.l','fmovemx'=>'fmovem.x','fmovep'=>'fmove.p',
	'fmoves'=>'fmove.s','fmovew'=>'fmove.w','fmovex'=>'fmove.x','fmulb'=>'fmul.b',
	'fmuld'=>'fmul.d','fmull'=>'fmul.l','fmulp'=>'fmul.p','fmuls'=>'fmul.s',
	'fmulw'=>'fmul.w','fmulx'=>'fmul.x','fnegb'=>'fneg.b','fnegd'=>'fneg.d',
	'fnegl'=>'fneg.l','fnegp'=>'fneg.p','fnegs'=>'fneg.s','fnegw'=>'fneg.w',
	'fnegx'=>'fneg.x','fremb'=>'frem.b','fremd'=>'frem.d','freml'=>'frem.l',
	'fremp'=>'frem.p','frems'=>'frem.s','fremw'=>'frem.w','fremx'=>'frem.x',
	'fsabsb'=>'fsabs.b','fsabsd'=>'fsabs.d','fsabsl'=>'fsabs.l',
	'fsabsp'=>'fsabs.p','fsabss'=>'fsabs.s','fsabsw'=>'fsabs.w',
	'fsabsx'=>'fsabs.x','fsaddb'=>'fsadd.b','fsaddd'=>'fsadd.d',
	'fsaddl'=>'fsadd.l','fsaddp'=>'fsadd.p','fsadds'=>'fsadd.s',
	'fsaddw'=>'fsadd.w','fsaddx'=>'fsadd.x','fscaleb'=>'fscale.b',
	'fscaled'=>'fscale.d','fscalel'=>'fscale.l','fscalep'=>'fscale.p',
	'fscales'=>'fscale.s','fscalew'=>'fscale.w','fscalex'=>'fscale.x',
	'fsdivb'=>'fsdiv.b','fsdivd'=>'fsdiv.d','fsdivl'=>'fsdiv.l',
	'fsdivp'=>'fsdiv.p','fsdivs'=>'fsdiv.s','fsdivw'=>'fsdiv.w',
	'fsdivx'=>'fsdiv.x','fseqb'=>'fseq.b','fsfb'=>'fsf.b','fsgeb'=>'fsge.b',
	'fsglb'=>'fsgl.b','fsgldivb'=>'fsgldiv.b','fsgldivd'=>'fsgldiv.d',
	'fsgldivl'=>'fsgldiv.l','fsgldivp'=>'fsgldiv.p','fsgldivs'=>'fsgldiv.s',
	'fsgldivw'=>'fsgldiv.w','fsgldivx'=>'fsgldiv.x','fsgleb'=>'fsgle.b',
	'fsglmulb'=>'fsglmul.b','fsglmuld'=>'fsglmul.d','fsglmull'=>'fsglmul.l',
	'fsglmulp'=>'fsglmul.p','fsglmuls'=>'fsglmul.s','fsglmulw'=>'fsglmul.w',
	'fsglmulx'=>'fsglmul.x','fsgtb'=>'fsgt.b','fsinb'=>'fsin.b',
	'fsincosb'=>'fsincos.b','fsincosd'=>'fsincos.d','fsincosl'=>'fsincos.l',
	'fsincosp'=>'fsincos.p','fsincoss'=>'fsincos.s','fsincosw'=>'fsincos.w',
	'fsincosx'=>'fsincos.x','fsind'=>'fsin.d','fsinhb'=>'fsinh.b',
	'fsinhd'=>'fsinh.d','fsinhl'=>'fsinh.l','fsinhp'=>'fsinh.p',
	'fsinhs'=>'fsinh.s','fsinhw'=>'fsinh.w','fsinhx'=>'fsinh.x','fsinl'=>'fsin.l',
	'fsinp'=>'fsin.p','fsins'=>'fsin.s','fsinw'=>'fsin.w','fsinx'=>'fsin.x',
	'fsleb'=>'fsle.b','fsltb'=>'fslt.b','fsmoveb'=>'fsmove.b',
	'fsmoved'=>'fsmove.d','fsmovel'=>'fsmove.l','fsmovep'=>'fsmove.p',
	'fsmoves'=>'fsmove.s','fsmovew'=>'fsmove.w','fsmovex'=>'fsmove.x',
	'fsmulb'=>'fsmul.b','fsmuld'=>'fsmul.d','fsmull'=>'fsmul.l',
	'fsmulp'=>'fsmul.p','fsmuls'=>'fsmul.s','fsmulw'=>'fsmul.w',
	'fsmulx'=>'fsmul.x','fsneb'=>'fsne.b','fsnegb'=>'fsneg.b','fsnegd'=>'fsneg.d',
	'fsnegl'=>'fsneg.l','fsnegp'=>'fsneg.p','fsnegs'=>'fsneg.s',
	'fsnegw'=>'fsneg.w','fsnegx'=>'fsneg.x','fsngeb'=>'fsnge.b',
	'fsnglb'=>'fsngl.b','fsngleb'=>'fsngle.b','fsngtb'=>'fsngt.b',
	'fsnleb'=>'fsnle.b','fsnltb'=>'fsnlt.b','fsogeb'=>'fsoge.b',
	'fsoglb'=>'fsogl.b','fsogtb'=>'fsogt.b','fsoleb'=>'fsole.b',
	'fsoltb'=>'fsolt.b','fsorb'=>'fsor.b','fsqrtb'=>'fsqrt.b','fsqrtd'=>'fsqrt.d',
	'fsqrtl'=>'fsqrt.l','fsqrtp'=>'fsqrt.p','fsqrts'=>'fsqrt.s',
	'fsqrtw'=>'fsqrt.w','fsqrtx'=>'fsqrt.x','fsseqb'=>'fsseq.b','fssfb'=>'fssf.b',
	'fssneb'=>'fssne.b','fssqrtb'=>'fssqrt.b','fssqrtd'=>'fssqrt.d',
	'fssqrtl'=>'fssqrt.l','fssqrtp'=>'fssqrt.p','fssqrts'=>'fssqrt.s',
	'fssqrtw'=>'fssqrt.w','fssqrtx'=>'fssqrt.x','fsstb'=>'fsst.b',
	'fssubb'=>'fssub.b','fssubd'=>'fssub.d','fssubl'=>'fssub.l',
	'fssubp'=>'fssub.p','fssubs'=>'fssub.s','fssubw'=>'fssub.w',
	'fssubx'=>'fssub.x','fstb'=>'fst.b','fsubb'=>'fsub.b','fsubd'=>'fsub.d',
	'fsubl'=>'fsub.l','fsubp'=>'fsub.p','fsubs'=>'fsub.s','fsubw'=>'fsub.w',
	'fsubx'=>'fsub.x','fsueqb'=>'fsueq.b','fsugeb'=>'fsuge.b','fsugtb'=>'fsugt.b',
	'fsuleb'=>'fsule.b','fsultb'=>'fsult.b','fsunb'=>'fsun.b','ftanb'=>'ftan.b',
	'ftand'=>'ftan.d','ftanhb'=>'ftanh.b','ftanhd'=>'ftanh.d','ftanhl'=>'ftanh.l',
	'ftanhp'=>'ftanh.p','ftanhs'=>'ftanh.s','ftanhw'=>'ftanh.w',
	'ftanhx'=>'ftanh.x','ftanl'=>'ftan.l','ftanp'=>'ftan.p','ftans'=>'ftan.s',
	'ftanw'=>'ftan.w','ftanx'=>'ftan.x','ftentoxb'=>'ftentox.b',
	'ftentoxd'=>'ftentox.d','ftentoxl'=>'ftentox.l','ftentoxp'=>'ftentox.p',
	'ftentoxs'=>'ftentox.s','ftentoxw'=>'ftentox.w','ftentoxx'=>'ftentox.x',
	'ftrapeql'=>'ftrapeq.l','ftrapeqw'=>'ftrapeq.w','ftrapfl'=>'ftrapf.l',
	'ftrapfw'=>'ftrapf.w','ftrapgel'=>'ftrapge.l','ftrapgew'=>'ftrapge.w',
	'ftrapglel'=>'ftrapgle.l','ftrapglew'=>'ftrapgle.w','ftrapgll'=>'ftrapgl.l',
	'ftrapglw'=>'ftrapgl.w','ftrapgtl'=>'ftrapgt.l','ftrapgtw'=>'ftrapgt.w',
	'ftraplel'=>'ftraple.l','ftraplew'=>'ftraple.w','ftrapltl'=>'ftraplt.l',
	'ftrapltw'=>'ftraplt.w','ftrapnel'=>'ftrapne.l','ftrapnew'=>'ftrapne.w',
	'ftrapngel'=>'ftrapnge.l','ftrapngew'=>'ftrapnge.w',
	'ftrapnglel'=>'ftrapngle.l','ftrapnglew'=>'ftrapngle.w',
	'ftrapngll'=>'ftrapngl.l','ftrapnglw'=>'ftrapngl.w','ftrapngtl'=>'ftrapngt.l',
	'ftrapngtw'=>'ftrapngt.w','ftrapnlel'=>'ftrapnle.l','ftrapnlew'=>'ftrapnle.w',
	'ftrapnltl'=>'ftrapnlt.l','ftrapnltw'=>'ftrapnlt.w','ftrapogel'=>'ftrapoge.l',
	'ftrapogew'=>'ftrapoge.w','ftrapogll'=>'ftrapogl.l','ftrapoglw'=>'ftrapogl.w',
	'ftrapogtl'=>'ftrapogt.l','ftrapogtw'=>'ftrapogt.w','ftrapolel'=>'ftrapole.l',
	'ftrapolew'=>'ftrapole.w','ftrapoltl'=>'ftrapolt.l','ftrapoltw'=>'ftrapolt.w',
	'ftraporl'=>'ftrapor.l','ftraporw'=>'ftrapor.w','ftrapseql'=>'ftrapseq.l',
	'ftrapseqw'=>'ftrapseq.w','ftrapsfl'=>'ftrapsf.l','ftrapsfw'=>'ftrapsf.w',
	'ftrapsnel'=>'ftrapsne.l','ftrapsnew'=>'ftrapsne.w','ftrapstl'=>'ftrapst.l',
	'ftrapstw'=>'ftrapst.w','ftraptl'=>'ftrapt.l','ftraptw'=>'ftrapt.w',
	'ftrapueql'=>'ftrapueq.l','ftrapueqw'=>'ftrapueq.w','ftrapugel'=>'ftrapuge.l',
	'ftrapugew'=>'ftrapuge.w','ftrapugtl'=>'ftrapugt.l','ftrapugtw'=>'ftrapugt.w',
	'ftrapulel'=>'ftrapule.l','ftrapulew'=>'ftrapule.w','ftrapultl'=>'ftrapult.l',
	'ftrapultw'=>'ftrapult.w','ftrapunl'=>'ftrapun.l','ftrapunw'=>'ftrapun.w',
	'ftstb'=>'ftst.b','ftstd'=>'ftst.d','ftstl'=>'ftst.l','ftstp'=>'ftst.p',
	'ftsts'=>'ftst.s','ftstw'=>'ftst.w','ftstx'=>'ftst.x','ftwotoxb'=>'ftwotox.b',
	'ftwotoxd'=>'ftwotox.d','ftwotoxl'=>'ftwotox.l','ftwotoxp'=>'ftwotox.p',
	'ftwotoxs'=>'ftwotox.s','ftwotoxw'=>'ftwotox.w','ftwotoxx'=>'ftwotox.x',
	'incb'=>'inc.b','incl'=>'inc.l','incw'=>'inc.w','jbccl'=>'jbcc.l',
	'jbccs'=>'jbcc.s','jbccw'=>'jbcc.w','jbcsl'=>'jbcs.l','jbcss'=>'jbcs.s',
	'jbcsw'=>'jbcs.w','jbeql'=>'jbeq.l','jbeqs'=>'jbeq.s','jbeqw'=>'jbeq.w',
	'jbgel'=>'jbge.l','jbges'=>'jbge.s','jbgew'=>'jbge.w','jbgtl'=>'jbgt.l',
	'jbgts'=>'jbgt.s','jbgtw'=>'jbgt.w','jbhil'=>'jbhi.l','jbhis'=>'jbhi.s',
	'jbhiw'=>'jbhi.w','jbhsl'=>'jbhs.l','jbhss'=>'jbhs.s','jbhsw'=>'jbhs.w',
	'jblel'=>'jble.l','jbles'=>'jble.s','jblew'=>'jble.w','jblol'=>'jblo.l',
	'jblos'=>'jblo.s','jblow'=>'jblo.w','jblsl'=>'jbls.l','jblss'=>'jbls.s',
	'jblsw'=>'jbls.w','jbltl'=>'jblt.l','jblts'=>'jblt.s','jbltw'=>'jblt.w',
	'jbmil'=>'jbmi.l','jbmis'=>'jbmi.s','jbmiw'=>'jbmi.w','jbnccl'=>'jbncc.l',
	'jbnccs'=>'jbncc.s','jbnccw'=>'jbncc.w','jbncsl'=>'jbncs.l',
	'jbncss'=>'jbncs.s','jbncsw'=>'jbncs.w','jbnel'=>'jbne.l','jbneql'=>'jbneq.l',
	'jbneqs'=>'jbneq.s','jbneqw'=>'jbneq.w','jbnes'=>'jbne.s','jbnew'=>'jbne.w',
	'jbngel'=>'jbnge.l','jbnges'=>'jbnge.s','jbngew'=>'jbnge.w',
	'jbngtl'=>'jbngt.l','jbngts'=>'jbngt.s','jbngtw'=>'jbngt.w',
	'jbnhil'=>'jbnhi.l','jbnhis'=>'jbnhi.s','jbnhiw'=>'jbnhi.w',
	'jbnhsl'=>'jbnhs.l','jbnhss'=>'jbnhs.s','jbnhsw'=>'jbnhs.w',
	'jbnlel'=>'jbnle.l','jbnles'=>'jbnle.s','jbnlew'=>'jbnle.w',
	'jbnlol'=>'jbnlo.l','jbnlos'=>'jbnlo.s','jbnlow'=>'jbnlo.w',
	'jbnlsl'=>'jbnls.l','jbnlss'=>'jbnls.s','jbnlsw'=>'jbnls.w',
	'jbnltl'=>'jbnlt.l','jbnlts'=>'jbnlt.s','jbnltw'=>'jbnlt.w',
	'jbnmil'=>'jbnmi.l','jbnmis'=>'jbnmi.s','jbnmiw'=>'jbnmi.w',
	'jbnnel'=>'jbnne.l','jbnnes'=>'jbnne.s','jbnnew'=>'jbnne.w',
	'jbnnzl'=>'jbnnz.l','jbnnzs'=>'jbnnz.s','jbnnzw'=>'jbnnz.w',
	'jbnpll'=>'jbnpl.l','jbnpls'=>'jbnpl.s','jbnplw'=>'jbnpl.w',
	'jbnvcl'=>'jbnvc.l','jbnvcs'=>'jbnvc.s','jbnvcw'=>'jbnvc.w',
	'jbnvsl'=>'jbnvs.l','jbnvss'=>'jbnvs.s','jbnvsw'=>'jbnvs.w',
	'jbnzel'=>'jbnze.l','jbnzes'=>'jbnze.s','jbnzew'=>'jbnze.w','jbnzl'=>'jbnz.l',
	'jbnzs'=>'jbnz.s','jbnzw'=>'jbnz.w','jbpll'=>'jbpl.l','jbpls'=>'jbpl.s',
	'jbplw'=>'jbpl.w','jbral'=>'jbra.l','jbras'=>'jbra.s','jbraw'=>'jbra.w',
	'jbsrl'=>'jbsr.l','jbsrs'=>'jbsr.s','jbsrw'=>'jbsr.w','jbvcl'=>'jbvc.l',
	'jbvcs'=>'jbvc.s','jbvcw'=>'jbvc.w','jbvsl'=>'jbvs.l','jbvss'=>'jbvs.s',
	'jbvsw'=>'jbvs.w','jbzel'=>'jbze.l','jbzes'=>'jbze.s','jbzew'=>'jbze.w',
	'leal'=>'lea.l','linkl'=>'link.l','linkw'=>'link.w','lpstopw'=>'lpstop.w',
	'lslb'=>'lsl.b','lsll'=>'lsl.l','lslw'=>'lsl.w','lsrb'=>'lsr.b',
	'lsrl'=>'lsr.l','lsrw'=>'lsr.w','moveal'=>'movea.l','moveaw'=>'movea.w',
	'moveb'=>'move.b','movecl'=>'movec.l','movel'=>'move.l','moveml'=>'movem.l',
	'movemw'=>'movem.w','movepl'=>'movep.l','movepw'=>'movep.w',
	'moveql'=>'moveq.l','movesb'=>'moves.b','movesl'=>'moves.l',
	'movesw'=>'moves.w','movew'=>'move.w','mulsl'=>'muls.l','mulsw'=>'muls.w',
	'mulul'=>'mulu.l','muluw'=>'mulu.w','mvsb'=>'mvs.b','mvsw'=>'mvs.w',
	'mvzb'=>'mvz.b','mvzw'=>'mvz.w','nbcdb'=>'nbcd.b','negb'=>'neg.b',
	'negl'=>'neg.l','negw'=>'neg.w','negxb'=>'negx.b','negxl'=>'negx.l',
	'negxw'=>'negx.w','notb'=>'not.b','notl'=>'not.l','notw'=>'not.w',
	'orb'=>'or.b','orib'=>'ori.b','oril'=>'ori.l','oriw'=>'ori.w','orl'=>'or.l',
	'orw'=>'or.w','pbacl'=>'pbac.l','pbacw'=>'pbac.w','pbasl'=>'pbas.l',
	'pbasw'=>'pbas.w','pbbcl'=>'pbbc.l','pbbcw'=>'pbbc.w','pbbsl'=>'pbbs.l',
	'pbbsw'=>'pbbs.w','pbccl'=>'pbcc.l','pbccw'=>'pbcc.w','pbcsl'=>'pbcs.l',
	'pbcsw'=>'pbcs.w','pbgcl'=>'pbgc.l','pbgcw'=>'pbgc.w','pbgsl'=>'pbgs.l',
	'pbgsw'=>'pbgs.w','pbicl'=>'pbic.l','pbicw'=>'pbic.w','pbisl'=>'pbis.l',
	'pbisw'=>'pbis.w','pblcl'=>'pblc.l','pblcw'=>'pblc.w','pblsl'=>'pbls.l',
	'pblsw'=>'pbls.w','pbscl'=>'pbsc.l','pbscw'=>'pbsc.w','pbssl'=>'pbss.l',
	'pbssw'=>'pbss.w','pbwcl'=>'pbwc.l','pbwcw'=>'pbwc.w','pbwsl'=>'pbws.l',
	'pbwsw'=>'pbws.w','pdbacw'=>'pdbac.w','pdbasw'=>'pdbas.w','pdbbcw'=>'pdbbc.w',
	'pdbbsw'=>'pdbbs.w','pdbccw'=>'pdbcc.w','pdbcsw'=>'pdbcs.w',
	'pdbgcw'=>'pdbgc.w','pdbgsw'=>'pdbgs.w','pdbicw'=>'pdbic.w',
	'pdbisw'=>'pdbis.w','pdblcw'=>'pdblc.w','pdblsw'=>'pdbls.w',
	'pdbscw'=>'pdbsc.w','pdbssw'=>'pdbss.w','pdbwcw'=>'pdbwc.w',
	'pdbwsw'=>'pdbws.w','peal'=>'pea.l','pmoveb'=>'pmove.b',
	'pmovefdl'=>'pmovefd.l','pmovefdq'=>'pmovefd.q','pmovel'=>'pmove.l',
	'pmoveq'=>'pmove.q','pmovew'=>'pmove.w','psacb'=>'psac.b','psasb'=>'psas.b',
	'psbcb'=>'psbc.b','psbsb'=>'psbs.b','psccb'=>'pscc.b','pscsb'=>'pscs.b',
	'psgcb'=>'psgc.b','psgsb'=>'psgs.b','psicb'=>'psic.b','psisb'=>'psis.b',
	'pslcb'=>'pslc.b','pslsb'=>'psls.b','psscb'=>'pssc.b','psssb'=>'psss.b',
	'pswcb'=>'pswc.b','pswsb'=>'psws.b','ptrapacl'=>'ptrapac.l',
	'ptrapacw'=>'ptrapac.w','ptrapasl'=>'ptrapas.l','ptrapasw'=>'ptrapas.w',
	'ptrapbcl'=>'ptrapbc.l','ptrapbcw'=>'ptrapbc.w','ptrapbsl'=>'ptrapbs.l',
	'ptrapbsw'=>'ptrapbs.w','ptrapccl'=>'ptrapcc.l','ptrapccw'=>'ptrapcc.w',
	'ptrapcsl'=>'ptrapcs.l','ptrapcsw'=>'ptrapcs.w','ptrapgcl'=>'ptrapgc.l',
	'ptrapgcw'=>'ptrapgc.w','ptrapgsl'=>'ptrapgs.l','ptrapgsw'=>'ptrapgs.w',
	'ptrapicl'=>'ptrapic.l','ptrapicw'=>'ptrapic.w','ptrapisl'=>'ptrapis.l',
	'ptrapisw'=>'ptrapis.w','ptraplcl'=>'ptraplc.l','ptraplcw'=>'ptraplc.w',
	'ptraplsl'=>'ptrapls.l','ptraplsw'=>'ptrapls.w','ptrapscl'=>'ptrapsc.l',
	'ptrapscw'=>'ptrapsc.w','ptrapssl'=>'ptrapss.l','ptrapssw'=>'ptrapss.w',
	'ptrapwcl'=>'ptrapwc.l','ptrapwcw'=>'ptrapwc.w','ptrapwsl'=>'ptrapws.l',
	'ptrapwsw'=>'ptrapws.w','pvalidl'=>'pvalid.l','rolb'=>'rol.b','roll'=>'rol.l',
	'rolw'=>'rol.w','rorb'=>'ror.b','rorl'=>'ror.l','rorw'=>'ror.w',
	'roxlb'=>'roxl.b','roxll'=>'roxl.l','roxlw'=>'roxl.w','roxrb'=>'roxr.b',
	'roxrl'=>'roxr.l','roxrw'=>'roxr.w','satsl'=>'sats.l','sbcdb'=>'sbcd.b',
	'sccb'=>'scc.b','scsb'=>'scs.b','seqb'=>'seq.b','sfb'=>'sf.b','sgeb'=>'sge.b',
	'sgtb'=>'sgt.b','shib'=>'shi.b','shsb'=>'shs.b','sleb'=>'sle.b',
	'slob'=>'slo.b','slsb'=>'sls.b','sltb'=>'slt.b','smib'=>'smi.b',
	'snccb'=>'sncc.b','sncsb'=>'sncs.b','sneb'=>'sne.b','sneqb'=>'sneq.b',
	'snfb'=>'snf.b','sngeb'=>'snge.b','sngtb'=>'sngt.b','snhib'=>'snhi.b',
	'snhsb'=>'snhs.b','snleb'=>'snle.b','snlob'=>'snlo.b','snlsb'=>'snls.b',
	'snltb'=>'snlt.b','snmib'=>'snmi.b','snneb'=>'snne.b','snnzb'=>'snnz.b',
	'snplb'=>'snpl.b','sntb'=>'snt.b','snvcb'=>'snvc.b','snvsb'=>'snvs.b',
	'snzb'=>'snz.b','snzeb'=>'snze.b','splb'=>'spl.b','stb'=>'st.b',
	'subal'=>'suba.l','subaw'=>'suba.w','subb'=>'sub.b','subib'=>'subi.b',
	'subil'=>'subi.l','subiw'=>'subi.w','subl'=>'sub.l','subqb'=>'subq.b',
	'subql'=>'subq.l','subqw'=>'subq.w','subw'=>'sub.w','subxb'=>'subx.b',
	'subxl'=>'subx.l','subxw'=>'subx.w','svcb'=>'svc.b','svsb'=>'svs.b',
	'swapw'=>'swap.w','szeb'=>'sze.b','tasb'=>'tas.b','tpccl'=>'tpcc.l',
	'tpccw'=>'tpcc.w','tpcsl'=>'tpcs.l','tpcsw'=>'tpcs.w','tpeql'=>'tpeq.l',
	'tpeqw'=>'tpeq.w','tpfl'=>'tpf.l','tpfw'=>'tpf.w','tpgel'=>'tpge.l',
	'tpgew'=>'tpge.w','tpgtl'=>'tpgt.l','tpgtw'=>'tpgt.w','tphil'=>'tphi.l',
	'tphiw'=>'tphi.w','tphsl'=>'tphs.l','tphsw'=>'tphs.w','tplel'=>'tple.l',
	'tplew'=>'tple.w','tplol'=>'tplo.l','tplow'=>'tplo.w','tplsl'=>'tpls.l',
	'tplsw'=>'tpls.w','tpltl'=>'tplt.l','tpltw'=>'tplt.w','tpmil'=>'tpmi.l',
	'tpmiw'=>'tpmi.w','tpnccl'=>'tpncc.l','tpnccw'=>'tpncc.w','tpncsl'=>'tpncs.l',
	'tpncsw'=>'tpncs.w','tpnel'=>'tpne.l','tpneql'=>'tpneq.l','tpneqw'=>'tpneq.w',
	'tpnew'=>'tpne.w','tpnfl'=>'tpnf.l','tpnfw'=>'tpnf.w','tpngel'=>'tpnge.l',
	'tpngew'=>'tpnge.w','tpngtl'=>'tpngt.l','tpngtw'=>'tpngt.w',
	'tpnhil'=>'tpnhi.l','tpnhiw'=>'tpnhi.w','tpnhsl'=>'tpnhs.l',
	'tpnhsw'=>'tpnhs.w','tpnlel'=>'tpnle.l','tpnlew'=>'tpnle.w',
	'tpnlol'=>'tpnlo.l','tpnlow'=>'tpnlo.w','tpnlsl'=>'tpnls.l',
	'tpnlsw'=>'tpnls.w','tpnltl'=>'tpnlt.l','tpnltw'=>'tpnlt.w',
	'tpnmil'=>'tpnmi.l','tpnmiw'=>'tpnmi.w','tpnnel'=>'tpnne.l',
	'tpnnew'=>'tpnne.w','tpnnzl'=>'tpnnz.l','tpnnzw'=>'tpnnz.w',
	'tpnpll'=>'tpnpl.l','tpnplw'=>'tpnpl.w','tpntl'=>'tpnt.l','tpntw'=>'tpnt.w',
	'tpnvcl'=>'tpnvc.l','tpnvcw'=>'tpnvc.w','tpnvsl'=>'tpnvs.l',
	'tpnvsw'=>'tpnvs.w','tpnzel'=>'tpnze.l','tpnzew'=>'tpnze.w','tpnzl'=>'tpnz.l',
	'tpnzw'=>'tpnz.w','tppll'=>'tppl.l','tpplw'=>'tppl.w','tptl'=>'tpt.l',
	'tptw'=>'tpt.w','tpvcl'=>'tpvc.l','tpvcw'=>'tpvc.w','tpvsl'=>'tpvs.l',
	'tpvsw'=>'tpvs.w','tpzel'=>'tpze.l','tpzew'=>'tpze.w','trapccl'=>'trapcc.l',
	'trapccw'=>'trapcc.w','trapcsl'=>'trapcs.l','trapcsw'=>'trapcs.w',
	'trapeql'=>'trapeq.l','trapeqw'=>'trapeq.w','trapfl'=>'trapf.l',
	'trapfw'=>'trapf.w','trapgel'=>'trapge.l','trapgew'=>'trapge.w',
	'trapgtl'=>'trapgt.l','trapgtw'=>'trapgt.w','traphil'=>'traphi.l',
	'traphiw'=>'traphi.w','traphsl'=>'traphs.l','traphsw'=>'traphs.w',
	'traplel'=>'traple.l','traplew'=>'traple.w','traplol'=>'traplo.l',
	'traplow'=>'traplo.w','traplsl'=>'trapls.l','traplsw'=>'trapls.w',
	'trapltl'=>'traplt.l','trapltw'=>'traplt.w','trapmil'=>'trapmi.l',
	'trapmiw'=>'trapmi.w','trapnccl'=>'trapncc.l','trapnccw'=>'trapncc.w',
	'trapncsl'=>'trapncs.l','trapncsw'=>'trapncs.w','trapnel'=>'trapne.l',
	'trapneql'=>'trapneq.l','trapneqw'=>'trapneq.w','trapnew'=>'trapne.w',
	'trapnfl'=>'trapnf.l','trapnfw'=>'trapnf.w','trapngel'=>'trapnge.l',
	'trapngew'=>'trapnge.w','trapngtl'=>'trapngt.l','trapngtw'=>'trapngt.w',
	'trapnhil'=>'trapnhi.l','trapnhiw'=>'trapnhi.w','trapnhsl'=>'trapnhs.l',
	'trapnhsw'=>'trapnhs.w','trapnlel'=>'trapnle.l','trapnlew'=>'trapnle.w',
	'trapnlol'=>'trapnlo.l','trapnlow'=>'trapnlo.w','trapnlsl'=>'trapnls.l',
	'trapnlsw'=>'trapnls.w','trapnltl'=>'trapnlt.l','trapnltw'=>'trapnlt.w',
	'trapnmil'=>'trapnmi.l','trapnmiw'=>'trapnmi.w','trapnnel'=>'trapnne.l',
	'trapnnew'=>'trapnne.w','trapnnzl'=>'trapnnz.l','trapnnzw'=>'trapnnz.w',
	'trapnpll'=>'trapnpl.l','trapnplw'=>'trapnpl.w','trapntl'=>'trapnt.l',
	'trapntw'=>'trapnt.w','trapnvcl'=>'trapnvc.l','trapnvcw'=>'trapnvc.w',
	'trapnvsl'=>'trapnvs.l','trapnvsw'=>'trapnvs.w','trapnzel'=>'trapnze.l',
	'trapnzew'=>'trapnze.w','trapnzl'=>'trapnz.l','trapnzw'=>'trapnz.w',
	'trappll'=>'trappl.l','trapplw'=>'trappl.w','traptl'=>'trapt.l',
	'traptw'=>'trapt.w','trapvcl'=>'trapvc.l','trapvcw'=>'trapvc.w',
	'trapvsl'=>'trapvs.l','trapvsw'=>'trapvs.w','trapzel'=>'trapze.l',
	'trapzew'=>'trapze.w','tstb'=>'tst.b','tstl'=>'tst.l','tstw'=>'tst.w',
);

# ラベル多重定義検出テーブル
my %g_already_declared_label;

# Motorola syntax のインストラクションにマッチする正規表現
my $g_regex_motorola_instruction =
	'abcd[b]?|add[blw]?|adda[lw]?|addi[blw]?|addq[blw]?|addx[blw]?|aline|and[blw]?'
.	'|andi[blw]?|asl[blw]?|asr[blw]?|bcc[lsw]?|bchg[bl]?|bclr[bl]?|bcs[lsw]?'
.	'|beq[lsw]?|bfchg|bfclr|bfexts|bfextu|bfffo|bfins|bfset|bftst|bge[lsw]?'
.	'|bgt[lsw]?|bhi[lsw]?|bhs[lsw]?|bitrev[l]?|bkpt|ble[lsw]?|blo[lsw]?|bls[lsw]?'
.	'|blt[lsw]?|bmi[lsw]?|bncc[lsw]?|bncs[lsw]?|bne[lsw]?|bneq[lsw]?|bnge[lsw]?'
.	'|bngt[lsw]?|bnhi[lsw]?|bnhs[lsw]?|bnle[lsw]?|bnlo[lsw]?|bnls[lsw]?|bnlt[lsw]?'
.	'|bnmi[lsw]?|bnne[lsw]?|bnnz[lsw]?|bnpl[lsw]?|bnvc[lsw]?|bnvs[lsw]?|bnz[lsw]?'
.	'|bnze[lsw]?|bpl[lsw]?|bra[lsw]?|bset[bl]?|bsr[lsw]?|btst[bl]?|bvc[lsw]?'
.	'|bvs[lsw]?|byterev[l]?|bze[lsw]?|callm|cas[blw]?|cas2[lw]?|chk[lw]?|chk2[blw]?'
.	'|cinva|cinvl|cinvp|clr[blw]?|cmp[blw]?|cmp2[blw]?|cmpa[lw]?|cmpi[blw]?'
.	'|cmpm[blw]?|cpusha|cpushl|cpushp|dbcc[w]?|dbcs[w]?|dbeq[w]?|dbf[w]?|dbge[w]?'
.	'|dbgt[w]?|dbhi[w]?|dbhs[w]?|dble[w]?|dblo[w]?|dbls[w]?|dblt[w]?|dbmi[w]?'
.	'|dbncc[w]?|dbncs[w]?|dbne[w]?|dbneq[w]?|dbnf[w]?|dbnge[w]?|dbngt[w]?|dbnhi[w]?'
.	'|dbnhs[w]?|dbnle[w]?|dbnlo[w]?|dbnls[w]?|dbnlt[w]?|dbnmi[w]?|dbnne[w]?'
.	'|dbnnz[w]?|dbnpl[w]?|dbnt[w]?|dbnvc[w]?|dbnvs[w]?|dbnz[w]?|dbnze[w]?|dbpl[w]?'
.	'|dbra[w]?|dbt[w]?|dbvc[w]?|dbvs[w]?|dbze[w]?|dec[blw]?|divs[lw]?|divsl[l]?'
.	'|divu[lw]?|divul[l]?|dos|eor[blw]?|eori[blw]?|exg[l]?|ext[lw]?|extb[l]?'
.	'|fabs[bdlpswx]?|facos[bdlpswx]?|fadd[bdlpswx]?|fasin[bdlpswx]?|fatan[bdlpswx]?'
.	'|fatanh[bdlpswx]?|fbeq[lw]?|fbf[lw]?|fbge[lw]?|fbgl[lw]?|fbgle[lw]?|fbgt[lw]?'
.	'|fble[lw]?|fblt[lw]?|fbne[lw]?|fbnge[lw]?|fbngl[lw]?|fbngle[lw]?|fbngt[lw]?'
.	'|fbnle[lw]?|fbnlt[lw]?|fboge[lw]?|fbogl[lw]?|fbogt[lw]?|fbole[lw]?|fbolt[lw]?'
.	'|fbor[lw]?|fbra[lw]?|fbseq[lw]?|fbsf[lw]?|fbsne[lw]?|fbst[lw]?|fbt[lw]?'
.	'|fbueq[lw]?|fbuge[lw]?|fbugt[lw]?|fbule[lw]?|fbult[lw]?|fbun[lw]?'
.	'|fcmp[bdlpswx]?|fcos[bdlpswx]?|fcosh[bdlpswx]?|fdabs[bdlpswx]?|fdadd[bdlpswx]?'
.	'|fdbeq|fdbf|fdbge|fdbgl|fdbgle|fdbgt|fdble|fdblt|fdbne|fdbnge|fdbngl|fdbngle'
.	'|fdbngt|fdbnle|fdbnlt|fdboge|fdbogl|fdbogt|fdbole|fdbolt|fdbor|fdbra|fdbseq'
.	'|fdbsf|fdbsne|fdbst|fdbt|fdbueq|fdbuge|fdbugt|fdbule|fdbult|fdbun'
.	'|fddiv[bdlpswx]?|fdiv[bdlpswx]?|fdmove[bdlpswx]?|fdmul[bdlpswx]?'
.	'|fdneg[bdlpswx]?|fdsqrt[bdlpswx]?|fdsub[bdlpswx]?|fetox[bdlpswx]?'
.	'|fetoxm1[bdlpswx]?|ff1[l]?|fgetexp[bdlpswx]?|fgetman[bdlpswx]?|fint[bdlpswx]?'
.	'|fintrz[bdlpswx]?|fline|flog10[bdlpswx]?|flog2[bdlpswx]?|flogn[bdlpswx]?'
.	'|flognp1[bdlpswx]?|fmod[bdlpswx]?|fmove[bdlpswx]?|fmovecr[x]?|fmovem[lx]?'
.	'|fmul[bdlpswx]?|fneg[bdlpswx]?|fnop|fpack|frem[bdlpswx]?|frestore'
.	'|fsabs[bdlpswx]?|fsadd[bdlpswx]?|fsave|fscale[bdlpswx]?|fsdiv[bdlpswx]?'
.	'|fseq[b]?|fsf[b]?|fsge[b]?|fsgl[b]?|fsgldiv[bdlpswx]?|fsgle[b]?'
.	'|fsglmul[bdlpswx]?|fsgt[b]?|fsin[bdlpswx]?|fsincos[bdlpswx]?|fsinh[bdlpswx]?'
.	'|fsle[b]?|fslt[b]?|fsmove[bdlpswx]?|fsmul[bdlpswx]?|fsne[b]?|fsneg[bdlpswx]?'
.	'|fsnge[b]?|fsngl[b]?|fsngle[b]?|fsngt[b]?|fsnle[b]?|fsnlt[b]?|fsoge[b]?'
.	'|fsogl[b]?|fsogt[b]?|fsole[b]?|fsolt[b]?|fsor[b]?|fsqrt[bdlpswx]?|fsseq[b]?'
.	'|fssf[b]?|fssne[b]?|fssqrt[bdlpswx]?|fsst[b]?|fssub[bdlpswx]?|fst[b]?'
.	'|fsub[bdlpswx]?|fsueq[b]?|fsuge[b]?|fsugt[b]?|fsule[b]?|fsult[b]?|fsun[b]?'
.	'|ftan[bdlpswx]?|ftanh[bdlpswx]?|ftentox[bdlpswx]?|ftrapeq[lw]?|ftrapf[lw]?'
.	'|ftrapge[lw]?|ftrapgl[lw]?|ftrapgle[lw]?|ftrapgt[lw]?|ftraple[lw]?|ftraplt[lw]?'
.	'|ftrapne[lw]?|ftrapnge[lw]?|ftrapngl[lw]?|ftrapngle[lw]?|ftrapngt[lw]?'
.	'|ftrapnle[lw]?|ftrapnlt[lw]?|ftrapoge[lw]?|ftrapogl[lw]?|ftrapogt[lw]?'
.	'|ftrapole[lw]?|ftrapolt[lw]?|ftrapor[lw]?|ftrapseq[lw]?|ftrapsf[lw]?'
.	'|ftrapsne[lw]?|ftrapst[lw]?|ftrapt[lw]?|ftrapueq[lw]?|ftrapuge[lw]?'
.	'|ftrapugt[lw]?|ftrapule[lw]?|ftrapult[lw]?|ftrapun[lw]?|ftst[bdlpswx]?'
.	'|ftwotox[bdlpswx]?|illegal|inc[blw]?|iocs|jbcc[lsw]?|jbcs[lsw]?|jbeq[lsw]?'
.	'|jbge[lsw]?|jbgt[lsw]?|jbhi[lsw]?|jbhs[lsw]?|jble[lsw]?|jblo[lsw]?|jbls[lsw]?'
.	'|jblt[lsw]?|jbmi[lsw]?|jbncc[lsw]?|jbncs[lsw]?|jbne[lsw]?|jbneq[lsw]?'
.	'|jbnge[lsw]?|jbngt[lsw]?|jbnhi[lsw]?|jbnhs[lsw]?|jbnle[lsw]?|jbnlo[lsw]?'
.	'|jbnls[lsw]?|jbnlt[lsw]?|jbnmi[lsw]?|jbnne[lsw]?|jbnnz[lsw]?|jbnpl[lsw]?'
.	'|jbnvc[lsw]?|jbnvs[lsw]?|jbnz[lsw]?|jbnze[lsw]?|jbpl[lsw]?|jbra[lsw]?'
.	'|jbsr[lsw]?|jbvc[lsw]?|jbvs[lsw]?|jbze[lsw]?|jmp|jsr|lea[l]?|link[lw]?'
.	'|lpstop[w]?|lsl[blw]?|lsr[blw]?|move[blw]?|move16|movea[lw]?|movec[l]?'
.	'|movem[lw]?|movep[lw]?|moveq[l]?|moves[blw]?|muls[lw]?|mulu[lw]?|mvs[bw]?'
.	'|mvz[bw]?|nbcd[b]?|neg[blw]?|negx[blw]?|nop|not[blw]?|or[blw]?|ori[blw]?|pack'
.	'|pbac[lw]?|pbas[lw]?|pbbc[lw]?|pbbs[lw]?|pbcc[lw]?|pbcs[lw]?|pbgc[lw]?'
.	'|pbgs[lw]?|pbic[lw]?|pbis[lw]?|pblc[lw]?|pbls[lw]?|pbsc[lw]?|pbss[lw]?'
.	'|pbwc[lw]?|pbws[lw]?|pdbac[w]?|pdbas[w]?|pdbbc[w]?|pdbbs[w]?|pdbcc[w]?'
.	'|pdbcs[w]?|pdbgc[w]?|pdbgs[w]?|pdbic[w]?|pdbis[w]?|pdblc[w]?|pdbls[w]?'
.	'|pdbsc[w]?|pdbss[w]?|pdbwc[w]?|pdbws[w]?|pea[l]?|pflush|pflusha|pflushan'
.	'|pflushn|pflushr|pflushs|ploadr|ploadw|plpar|plpaw|pmove[blqw]?|pmovefd[lq]?'
.	'|prestore|psac[b]?|psas[b]?|psave|psbc[b]?|psbs[b]?|pscc[b]?|pscs[b]?|psgc[b]?'
.	'|psgs[b]?|psic[b]?|psis[b]?|pslc[b]?|psls[b]?|pssc[b]?|psss[b]?|pswc[b]?'
.	'|psws[b]?|ptestr|ptestw|ptrapac[lw]?|ptrapas[lw]?|ptrapbc[lw]?|ptrapbs[lw]?'
.	'|ptrapcc[lw]?|ptrapcs[lw]?|ptrapgc[lw]?|ptrapgs[lw]?|ptrapic[lw]?|ptrapis[lw]?'
.	'|ptraplc[lw]?|ptrapls[lw]?|ptrapsc[lw]?|ptrapss[lw]?|ptrapwc[lw]?|ptrapws[lw]?'
.	'|pvalid[l]?|reset|rol[blw]?|ror[blw]?|roxl[blw]?|roxr[blw]?|rtd|rte|rtm|rtr|rts'
.	'|sats[l]?|sbcd[b]?|scc[b]?|scs[b]?|seq[b]?|sf[b]?|sge[b]?|sgt[b]?|shi[b]?'
.	'|shs[b]?|sle[b]?|slo[b]?|sls[b]?|slt[b]?|smi[b]?|sncc[b]?|sncs[b]?|sne[b]?'
.	'|sneq[b]?|snf[b]?|snge[b]?|sngt[b]?|snhi[b]?|snhs[b]?|snle[b]?|snlo[b]?'
.	'|snls[b]?|snlt[b]?|snmi[b]?|snne[b]?|snnz[b]?|snpl[b]?|snt[b]?|snvc[b]?'
.	'|snvs[b]?|snz[b]?|snze[b]?|spl[b]?|st[b]?|stop|sub[blw]?|suba[lw]?|subi[blw]?'
.	'|subq[blw]?|subx[blw]?|svc[b]?|svs[b]?|swap[w]?|sxcall|sze[b]?|tas[b]?'
.	'|tpcc[lw]?|tpcs[lw]?|tpeq[lw]?|tpf[lw]?|tpge[lw]?|tpgt[lw]?|tphi[lw]?|tphs[lw]?'
.	'|tple[lw]?|tplo[lw]?|tpls[lw]?|tplt[lw]?|tpmi[lw]?|tpncc[lw]?|tpncs[lw]?'
.	'|tpne[lw]?|tpneq[lw]?|tpnf[lw]?|tpnge[lw]?|tpngt[lw]?|tpnhi[lw]?|tpnhs[lw]?'
.	'|tpnle[lw]?|tpnlo[lw]?|tpnls[lw]?|tpnlt[lw]?|tpnmi[lw]?|tpnne[lw]?|tpnnz[lw]?'
.	'|tpnpl[lw]?|tpnt[lw]?|tpnvc[lw]?|tpnvs[lw]?|tpnz[lw]?|tpnze[lw]?|tppl[lw]?'
.	'|tpt[lw]?|tpvc[lw]?|tpvs[lw]?|tpze[lw]?|trap|trapcc[lw]?|trapcs[lw]?'
.	'|trapeq[lw]?|trapf[lw]?|trapge[lw]?|trapgt[lw]?|traphi[lw]?|traphs[lw]?'
.	'|traple[lw]?|traplo[lw]?|trapls[lw]?|traplt[lw]?|trapmi[lw]?|trapncc[lw]?'
.	'|trapncs[lw]?|trapne[lw]?|trapneq[lw]?|trapnf[lw]?|trapnge[lw]?|trapngt[lw]?'
.	'|trapnhi[lw]?|trapnhs[lw]?|trapnle[lw]?|trapnlo[lw]?|trapnls[lw]?|trapnlt[lw]?'
.	'|trapnmi[lw]?|trapnne[lw]?|trapnnz[lw]?|trapnpl[lw]?|trapnt[lw]?|trapnvc[lw]?'
.	'|trapnvs[lw]?|trapnz[lw]?|trapnze[lw]?|trappl[lw]?|trapt[lw]?|trapv|trapvc[lw]?'
.	'|trapvs[lw]?|trapze[lw]?|tst[blw]?|unlk|unpk'
;

# 何にもマッチしない正規表現
my $g_regex_fail = '(*FAIL)';


# シンボル名に利用可能な文字
#	HAS の詳細仕様が不明なので推測に基づく。
#	GAS では $ がラベル名として利用可能。
my $g_regex_symbol_char_wo_num = '[a-zA-Z_?~$.]';
my $g_regex_symbol_char_with_num = '[0-9a-zA-Z_?~$.]';

# 後続に名前として認識される文字が存在しないことを確認する正規表現
#	例えば、/fp$g_regex_end_of_name/ とすると、fp の後続にシンボル名と認識される
#	文字列が存在しないことを保証することができ、誤って fputs などにマッチしないように
#	できる。オペランドサイズ指定を可能にするため、後続 . は許容する。
my $g_regex_end_of_name = '(?![0-9a-zA-Z_?~$])';

# 16 進数にマッチする正規表現
#	16 進数は、0x または $ から始まる。
#	視認性向上のため _ 区切り表記が許容されている。
my $g_regex_hex = '(?:(?:0x|\\$)[0-9a-fA-F_]+' . $g_regex_end_of_name . ')';

# 10 進数にマッチする正規表現
#	視認性向上のため _ 区切り表記が許容されている。
my $g_regex_dec = '(?:[0-9_]+' . $g_regex_end_of_name . ')';

# 8 進数にマッチする正規表現
#	8 進数は、0o または @ から始まる。
#	視認性向上のため _ 区切り表記が許容されている。
my $g_regex_oct = '(?:(?:0o|\\@)[0-7_]+' . $g_regex_end_of_name . ')';

# 2 進数にマッチする正規表現
#	2 進数は、0b または % から始まる。
#	視認性向上のため _ 区切り表記が許容されている。
my $g_regex_bin = '(?:(?:0b|\\%)[01_]+' . $g_regex_end_of_name . ')';

# 浮動小数にマッチする正規表現
#	HAS 固有の記述方法。
#	1234.w が浮動小数 + w と認識されるようなケースを避けるため、
#	否定先読みで抑止することが必須。
my $g_regex_float = 
	'(?:'
		# 0f1.2345
.		'0f[0-9]*(?:\\.[0-9]*)?(?![a-zA-Z_.])'
		# 123.
.	'|'.'[0-9]+\\.[0-9]*(?![a-zA-Z_.])'
		# .123
.	'|'.'[0-9]*\\.[0-9]+(?![a-zA-Z_.])'
		# !3f80_0000
.	'|'.'\\![0-9a-fA-F_]+(?![g-zG-Z_.])'
.	')';

# 整数（16/10/8/2 進数）にマッチする正規表現
my $g_regex_int =
	'(?:'
.		$g_regex_hex
.	'|'.$g_regex_oct
.	'|'.$g_regex_bin
.	'|'.$g_regex_dec
.	')';

# 整数（16/10/8/2 進数）または浮動小数にマッチする正規表現
#	誤認識を避けるため、10 進数は最後に評価する。
my $g_regex_number =
	'(?:'
.		$g_regex_hex
.	'|'.$g_regex_oct
.	'|'.$g_regex_bin
.	'|'.$g_regex_float
.	'|'.$g_regex_dec
.	')';

# 文字列リテラルにマッチする正規表現
my $g_regex_string_literal =
	'(?:'
.		'\"(?:[^\\\\\"]|\\\\.)*?\"'
.	'|'.'\'(?:[^\\\\\']|\\\\.)*?\''
.	')';



# ラベルまたはシンボル名にマッチする正規表現
#	数字からは開始しない。
#	.L123.4 のように、途中にドットが割り込むことも許容する。
my $g_regex_label_and_symbol = '(?:' . $g_regex_symbol_char_wo_num . $g_regex_symbol_char_with_num . '*' . $g_regex_end_of_name . ')';

# HAS 拡張機能のローカルラベル名の参照にマッチする正規表現
#	HAS
#		@f @@f @@@f ...
#		@b @@b @@@b ...
#		1f ～ 9999f	（2 桁以上は HAS060 拡張）
#		1b ～ 9999b	（2 桁以上は HAS060 拡張）
#	GAS
#		1f ～ 9999f
#		1b ～ 9999b
my %g_regex_ref_local_label;
$g_regex_ref_local_label{'has'} = '(?:(?:@+[fb]|[1-9][0-9]*[fb])' . $g_regex_end_of_name . ')';
$g_regex_ref_local_label{'gas'} = '(?:(?:[1-9][0-9]*[fb])' . $g_regex_end_of_name . ')';

# ローカルラベルにマッチする正規表現
#	HAS
#		@@:
#		1: ～ 9999:	（2 桁以上は HAS060 拡張）
#	GAS
#		1: ～ 9999:
my %g_regex_local_label;
$g_regex_local_label{'has'} = '(?:(?:@@|[1-9][0-9]*)' . $g_regex_end_of_name . ')';
$g_regex_local_label{'gas'} = '(?:(?:[1-9][0-9]*)' . $g_regex_end_of_name . ')';


# 丸括弧にマッチする正規表現
my $g_regex_parenthesis = '(?:[\\(\\)])';

# 単項演算子にマッチする正規表現
my %g_regex_unary_operator;
#	HAS 出典元：「ぷにぐらま～ずまにゅある 第七版 第二刷」
$g_regex_unary_operator{'has'} =
	'(?:'
.		'\\.pos\\.|\\+'				# 正
.	'|'.'\\.neg\\.|\\-'				# 負
.	'|'.'\\.not\\.'					# 論理 NOT
.	'|'.'\\.high\\.'				# ロングワード(32ビット)の下位ワードの上位バイトを分離する
.	'|'.'\\.low\\.'					# ロングワード(32ビット)の下位ワードの下位バイトを分離する
.	'|'.'\\.highw\\.'				# ロングワード(32ビット)の上位ワードを分離する
.	'|'.'\\.loww\\.'				# ロングワード(32ビット)の下位ワードを分離する
.	'|'.'\\.nul\\.'					# 常に 0 を返す
	# 以下 HAS060 拡張
.	'|'.'\\.notb\\.'				# 論理 NOT（ 8ビット値）
.	'|'.'\\.notw\\.'				# 論理 NOT（16ビット値）
.	')';
#	GAS 出典元：GNU Assembler Manual
$g_regex_unary_operator{'gas'} =
	'(?:'
									# + は定義されていないようだ。
.		'\\-'						# Negation. Two’s complement negation.
.	'|'.'\\~'						# Complementation. Bitwise not.
.	')';


# 二項演算子にマッチする正規表現
my %g_regex_binary_operator;
#	HAS 出典元：「ぷにぐらま～ずまにゅある 第七版 第二刷」
$g_regex_binary_operator{'has'} =
	'(?:'
.		'\\.mod\\.'					# 剰余	HAS では % は使えない
.	'|'.'\\.shr\\.|>>'				# 右論理シフト
.	'|'.'\\.shl\\.|<<'				# 左論理シフト
.	'|'.'\\.asr\\.'					# 右算術シフト
.	'|'.'\\.add\\.|\\+'				# 加算
.	'|'.'\\.sub\\.|\\-'				# 減算
.	'|'.'\\.mul\\.|\\*'				# 乗算
.	'|'.'\\.div\\.|\\/'				# 除算
.	'|'.'\\.eq\\.|==|='				# 等しい
.	'|'.'\\.ne\\.|<>|\\!='			# 等しくない
.	'|'.'\\.le\\.|<='				# le
.	'|'.'\\.lt\\.|<'				# lt	<< や <= や <> にマッチしてしまうので、それらより後に評価する。
.	'|'.'\\.ge\\.|>='				# ge
.	'|'.'\\.gt\\.|>'				# gt	>> や >= にマッチしてしまうので、それらより後に評価する。
.	'|'.'\\.sle\\.|\\.<=\\.'		# 符号つき le	「ぷにぐらま～ずまにゅある 第七版 第二刷」では .<= となっていたが .<=. に修正した。
.	'|'.'\\.slt\\.|\\.<\\.'			# 符号つき lt
.	'|'.'\\.sge\\.|\\.>=\\.'		# 符号つき ge
.	'|'.'\\.sgt\\.|\\.>\\.'			# 符号つき gt
.	'|'.'\\.and\\.|\\&'				# 論理 AND
.	'|'.'\\.or\\.|\\|'				# 論理 OR
.	'|'.'\\.xor\\.|\\.eor\\.|\\^'	# 排他的 OR
.	')';
#	GAS 出典元：GNU Assembler Manual
$g_regex_binary_operator{'gas'} =
	'(?:'
.		'\\*'		# Multiplication.
.	'|'.'\\/'		# Division.
.	'|'.'\\%'		# Remainder.
.	'|'.'<<'		# Shift Left.
.	'|'.'<'			# 					<< にマッチしてしまうので、それより後に評価する。
.	'|'.'>>'		# Shift Right.
.	'|'.'>'			# 					>> にマッチしてしまうので、それより後に評価する。
.	'|'.'\\|'		# Bitwise Inclusive Or.
.	'|'.'\\&'		# Bitwise And.
.	'|'.'\\^'		# Bitwise Exclusive Or.
.	'|'.'\\!'		# Bitwise Or Not.
.	'|'.'\\+'		# Addition.
.	'|'.'\\-'		# Subtraction.
.	')';

# 演算子にマッチする正規表現
my %g_regex_operator;
foreach my $asm_mode (@g_asm_modes) {
	$g_regex_operator{$asm_mode} =
		'(?:'
	.		$g_regex_unary_operator{$asm_mode}
	.	'|'.$g_regex_binary_operator{$asm_mode}
	.	')';
}

# 式にマッチする正規表現
my %g_regex_expression;
$g_regex_expression{'has'} =
	'(?:'
.		'(?:'
.			$g_regex_label_and_symbol
.		'|'.$g_regex_ref_local_label{'has'}
.		'|'.$g_regex_number
.		'|'.$g_regex_operator{'has'}
.		'|'.$g_regex_parenthesis
.		')+'
.	')';
$g_regex_expression{'gas'} =
	'(?:'
.		'(?:'
.			$g_regex_label_and_symbol
.		'|'.$g_regex_ref_local_label{'gas'}
.		'|'.$g_regex_number
.		'|'.$g_regex_operator{'gas'}
.		'|'.$g_regex_parenthesis
.		')+'
.	')';

# コメントにマッチする正規表現
#	HAS では * ; 以降がコメントと見なされる。
#	GAS では * # | 以降がコメントと見なされるようだ。
#	GAS の | コメントは inline asm 記述時に発生する。
my $g_regex_comment = '(?:[*\\#|;].*$)';

# 行末コメントにマッチする正規表現
#	数式で利用する * や | などの演算子がコメントと誤って解釈されることを避けるため、
#	行末コメントは必ずスペースに後続する必要がある。
my $g_regex_line_end_comment = '(?:\s+' . $g_regex_comment . ')';

# 行末または行末コメントにマッチする正規表現
my $g_regex_end = '(?:$|' . $g_regex_line_end_comment . ')';

# 各種オペランドサイズにマッチする正規表現
#	.b = byte(1bytes)
#	.w = word(2bytes)
#	.l = long(4bytes)
#	.s = 単精度実数(4bytes)
#	.d = 倍精度実数(8bytes)
#	.x = 拡張精度実数(12bytes)
#	.p = パックドデシマル(12bytes)
#
#	HAS と GAS の Motorola Syntax では .b .w .l のように . を使い、
#	GAS の MIT Syntax では :b :w :l のように : を使う。
my $g_regex_opsize = '(?:[:.][bwlsdxp]' . $g_regex_end_of_name . ')';

# レジスタのスケールにマッチする正規表現
#	HAS と GAS の Motorola Syntax では *1 *2 *4 *8 のように * を使い、
#	GAS の MIT Syntax では :1 :2 :4 :8 のように : を使う。
my $g_regex_register_scale = '(?:[:*][1248]' . $g_regex_end_of_name . ')';


# ディレクティブにマッチする正規表現
#	HAS のディレクティブは、冒頭の . が省略可能なため、インストラクションとの
#	区別が難しい。やむを得ず全ディレクティブをパターンマッチするしかない。
#	ここでは「ぷにぐらま～ずまにゅある 第七版 第二刷」の HAS の解説に
#	書かれている情報を元に正規表現を定義している。
my %g_regex_directive;
$g_regex_directive{'has'} =
	'(?:'
.		'\.?'
.		'(?:'
		# アセンブラ制御
.			'text'
.		'|'.'data'
.		'|'.'bss'
.		'|'.'stack'
.		'|'.'offset'
.		'|'.'include'
.		'|'.'comm'
.		'|'.'end'
.		'|'.'org'
.		'|'.'comment'
.		'|'.'fail'
.		'|'.'request'
.		'|'.'cpu'
.		'|'.'fpid'
.		'|'.'rdata'
.		'|'.'rldata'
.		'|'.'rbbs'
.		'|'.'rlbbs'
.		'|'.'rstack'
.		'|'.'rlstack'
.		'|'.'rcomm'
.		'|'.'rlcomm'
.		'|'.'pragma'
		# 外部名指定
.		'|'.'globl'
.		'|'.'global'
.		'|'.'xdef'
.		'|'.'public'
.		'|'.'entry'
.		'|'.'xref'
.		'|'.'extrn'
.		'|'.'external'
		# シンボル値定義
		#	g_regex_symbol_definition_directive に分離した。
		# マクロ制御
.		'|'.'macro'
.		'|'.'local'
.		'|'.'endm'
.		'|'.'exitm'
.		'|'.'rept'
.		'|'.'irp'
.		'|'.'irpc'
		# データ定義・領域確保
.		'|'.'dc' . $g_regex_opsize . '?'
.		'|'.'dcb' . $g_regex_opsize . '?'
.		'|'.'ds' . $g_regex_opsize . '?'
.		'|'.'even'
.		'|'.'align'
.		'|'.'quad'
		# 条件つきアセンブリ
		#	g_regex_conditional_assembly_directive
		#	g_regex_conditional_assembly_noarg_directive に分離した。
		# リスティング制御
.		'|'.'list'
.		'|'.'nlist'
.		'|'.'page'
.		'|'.'title'
.		'|'.'subttl'
.		'|'.'lall'
.		'|'.'sall'
.		'|'.'width'
		# シンボリックデバッグ情報指定
.		'|'.'file'
.		'|'.'ln'
.		'|'.'def'
.		'|'.'endef'
.		'|'.'val'
.		'|'.'scl'
.		'|'.'type'
.		'|'.'tag'
.		'|'.'line'
.		'|'.'size'
.		'|'.'dim'
		# cpu 種別の指定
.		'|'.'68000'
.		'|'.'68010'
.		'|'.'68020'
.		'|'.'68030'
.		'|'.'68040'
		# 以下 HAS060 拡張
.		'|'.'68060'
.		'|'.'insert'
.		')'
.		$g_regex_end_of_name
.	')';
#	GAS のディレクティブの全貌が不明。m68k-elf-gcc からは、ドキュメントに記載がない
#	様々なディレクティブが出力されてくる。これら全てに正確にマッチする正規表現を
#	定義することは難しい。
#	幸い、GAS のディレクティブは . で始まるというルールがあるので、それに従い
#	正規表現を定義すれば問題ない。
$g_regex_directive{'gas'} = '(?:\\.[a-zA-Z][0-9a-zA-Z_]*' . $g_regex_opsize . '?' . $g_regex_end_of_name .')';

# ラベル定義ディレクティブにマッチする正規表現
#	HAS の場合は冒頭 . が省略可能。
#	HAS と GAS で、local ディレクティブの意味が異なるので注意。
my %g_regex_label_definition_directive;
$g_regex_label_definition_directive{'has'} = '(?:\\.?(?:local|globl|global|xdef|public|entry|xref|extrn|external)' . $g_regex_end_of_name . ')';
$g_regex_label_definition_directive{'gas'} = '(?:\\.(?:local|globl|global|extern|weak)' . $g_regex_end_of_name . ')';

# シンボル定義ディレクティブにマッチする正規表現
#	m68k-elf-gcc から出力されるアセンブリコードには含まれないので、
#	GAS の定義は不要である。
my %g_regex_symbol_definition_directive;
$g_regex_symbol_definition_directive{'has'} =
	'(?:'
.		'\\.?'
.		'(?:'
.			'equ'
.		'|'.'set'
.		'|'.'reg'
.		'|'.'fequ' . $g_regex_opsize . '?'
.		'|'.'fset' . $g_regex_opsize . '?'
.		')'
.		$g_regex_end_of_name
.	')';
$g_regex_symbol_definition_directive{'gas'} = $g_regex_fail;

# 条件付きアセンブリディレクティブにマッチする正規表現
#	m68k-elf-gcc から出力されるアセンブリコードには含まれないので、
#	GAS の定義は不要である。
my %g_regex_conditional_assembly_directive;
$g_regex_conditional_assembly_directive{'has'} =
	'(?:'
.		'\\.?'
.		'(?:'
.			'if'
.		'|'.'ifeq'
.		'|'.'iff'
.		'|'.'ifne'
.		'|'.'ifdef'
.		'|'.'ifndef'
.		'|'.'elseif'
.		')'
.		$g_regex_end_of_name
.	')';
$g_regex_conditional_assembly_directive{'gas'} = $g_regex_fail;

# 条件付きアセンブリの引数無しディレクティブにマッチする正規表現
#	m68k-elf-gcc から出力されるアセンブリコードには含まれないので、
#	GAS の定義は不要である。
my %g_regex_conditional_assembly_noarg_directive;
$g_regex_conditional_assembly_noarg_directive{'has'} =
	'(?:'
.		'\\.?'
.		'(?:'
.			'else'
.		'|'.'endif'
.		'|'.'endc'
.		')'
.		$g_regex_end_of_name
.	')';
$g_regex_conditional_assembly_noarg_directive{'gas'} = $g_regex_fail;


# インストラクションにマッチする正規表現
#	0 から始まる文字列は除外する。
my $g_regex_instruction = '(?:[a-zA-Z][0-9a-zA-Z]*' . $g_regex_opsize . '?' . $g_regex_end_of_name .')';

# ビットフィールド（-m68030 指定時に出現）にマッチする正規表現
#	例:
#		{1:2}
#		{#1:#2}
#	参考:
#		https://stdkmd.net/bitfield/
my $g_regex_bitfield = '(?:\\{(?:\\#)?' . $g_regex_int . '\\:(?:\\#)?' . $g_regex_int . '\\})';

# 各種レジスタにマッチする正規表現
#	「ぷにぐらま～ずまにゅある 第七版 第二刷」に記載されている全レジスタを定義している。
#	ここで定義しているものが GAS で利用可能なレジスタと一致しているかは未確認。
#
#	HAS モードではレジスタ名に % のようなプリフィックスが付かない。
#	そのため、レジスタ名がラベルの一部と誤認識される可能性や、
#	a6 を意味する fp と fp0-fp7 が誤認識される危険がある。
#	このような問題を回避するため。レジスタ名末尾に否定的先読みを意味する
#	$g_regex_end_of_name をマッチさせることが必須である。
my %g_regex_register;
$g_regex_register{'has'}{'dn'}		= "(?:z?d[0-7]$g_regex_end_of_name$g_regex_opsize?)";
$g_regex_register{'has'}{'an'}		= "(?:(?:z?a[0-7]|z?fp|z?sp)$g_regex_end_of_name$g_regex_opsize?)";
$g_regex_register{'has'}{'ssp'}		= "(?:ssp$g_regex_end_of_name)";
$g_regex_register{'has'}{'usp'}		= "(?:usp$g_regex_end_of_name)";
$g_regex_register{'has'}{'pc'}		= "(?:(?:z?pc|opc)$g_regex_end_of_name)";
$g_regex_register{'has'}{'sr'}		= "(?:sr$g_regex_end_of_name)";
$g_regex_register{'has'}{'ccr'}		= "(?:ccr$g_regex_end_of_name)";

$g_regex_register{'has'}{'sfc'}		= "(?:sfc$g_regex_end_of_name)";
$g_regex_register{'has'}{'dfc'}		= "(?:dfc$g_regex_end_of_name)";
$g_regex_register{'has'}{'vbr'}		= "(?:vbr$g_regex_end_of_name)";

$g_regex_register{'has'}{'msp'}		= "(?:msp$g_regex_end_of_name)";
$g_regex_register{'has'}{'isp'}		= "(?:isp$g_regex_end_of_name)";
$g_regex_register{'has'}{'cacr'}	= "(?:cacr$g_regex_end_of_name)";
$g_regex_register{'has'}{'caar'}	= "(?:caar$g_regex_end_of_name)";
$g_regex_register{'has'}{'buscr'}	= "(?:buscr$g_regex_end_of_name)";
$g_regex_register{'has'}{'pcr'}		= "(?:pcr$g_regex_end_of_name)";	# 「ぷにぐらま～ずまにゅある 第七版 第二刷」では pc となっていたが pcr に修正した。

$g_regex_register{'has'}{'crp'}		= "(?:crp$g_regex_end_of_name)";
$g_regex_register{'has'}{'srp'}		= "(?:srp$g_regex_end_of_name)";
$g_regex_register{'has'}{'tc'}		= "(?:tc$g_regex_end_of_name)";
$g_regex_register{'has'}{'ttn'}		= "(?:tt[0-1]$g_regex_end_of_name)";
$g_regex_register{'has'}{'mmusr'}	= "(?:mmusr$g_regex_end_of_name)";
$g_regex_register{'has'}{'psr'}		= "(?:psr$g_regex_end_of_name)";

$g_regex_register{'has'}{'urp'}		= "(?:urp$g_regex_end_of_name)";
$g_regex_register{'has'}{'ittn'}	= "(?:itt[0-1]$g_regex_end_of_name)";
$g_regex_register{'has'}{'dttn'}	= "(?:dtt[0-1]$g_regex_end_of_name)";
$g_regex_register{'has'}{'nc'}		= "(?:nc$g_regex_end_of_name)";
$g_regex_register{'has'}{'dc'}		= "(?:dc$g_regex_end_of_name)";
$g_regex_register{'has'}{'ic'}		= "(?:ic$g_regex_end_of_name)";
$g_regex_register{'has'}{'bc'}		= "(?:bc$g_regex_end_of_name)";

$g_regex_register{'has'}{'drp'}		= "(?:drp$g_regex_end_of_name)";
$g_regex_register{'has'}{'cal'}		= "(?:cal$g_regex_end_of_name)";
$g_regex_register{'has'}{'val'}		= "(?:val$g_regex_end_of_name)";
$g_regex_register{'has'}{'scc'}		= "(?:scc$g_regex_end_of_name)";
$g_regex_register{'has'}{'ac'}		= "(?:ac$g_regex_end_of_name)";
$g_regex_register{'has'}{'pcsr'}	= "(?:pcsr$g_regex_end_of_name)";
$g_regex_register{'has'}{'badn'}	= "(?:bad[0-7]$g_regex_end_of_name)";
$g_regex_register{'has'}{'bacn'}	= "(?:bac[0-7]$g_regex_end_of_name)";

$g_regex_register{'has'}{'fpn'}		= "(?:fp[0-7]$g_regex_end_of_name)";
$g_regex_register{'has'}{'fpcr'}	= "(?:fpcr$g_regex_end_of_name)";
$g_regex_register{'has'}{'fpsr'}	= "(?:fpsr$g_regex_end_of_name)";
$g_regex_register{'has'}{'fpiar'}	= "(?:fpiar$g_regex_end_of_name)";

foreach my $key (keys(%{$g_regex_register{'has'}})) {
	$g_regex_register{'gas'}{$key} = '%' . $g_regex_register{'has'}{$key};
}

# 正規表現を組み合わせる
foreach my $asm_mode (@g_asm_modes) {
	# Dn:Dn（-m68030 指定時に出現）にマッチする正規表現
	$g_regex_register{$asm_mode}{'dn_dn'} = '(?:' . $g_regex_register{$asm_mode}{'dn'} . '\\:' . $g_regex_register{$asm_mode}{'dn'} . ')';

	# Xi にマッチする正規表現
	$g_regex_register{$asm_mode}{'xi'} =
		'(?:'
	.		'(?:'
	.			$g_regex_register{$asm_mode}{'dn'}
	.		'|'.$g_regex_register{$asm_mode}{'an'}
	.		')'
	.		'(?:'
	.			$g_regex_register_scale		# スケールの指定（-m68030 指定時に出現）
	.		')?'
	.	')';


	# An または pc にマッチする正規表現
	$g_regex_register{$asm_mode}{'apc'} =
		'(?:'
	.		$g_regex_register{$asm_mode}{'an'}
	.	'|'.$g_regex_register{$asm_mode}{'pc'}
	.	')';

	# 全レジスタにマッチする正規表現
	$g_regex_register{$asm_mode}{'all'} =
		'(?:'
	.		$g_regex_register{$asm_mode}{'dn_dn'}
	.	'|'.$g_regex_register{$asm_mode}{'dn'}
	.	'|'.$g_regex_register{$asm_mode}{'an'}
	.	'|'.$g_regex_register{$asm_mode}{'sr'}
	.	'|'.$g_regex_register{$asm_mode}{'ccr'}
	.	'|'.$g_regex_register{$asm_mode}{'fpn'}
	.	'|'.$g_regex_register{$asm_mode}{'fpcr'}
	.	'|'.$g_regex_register{$asm_mode}{'fpsr'}
	.	'|'.$g_regex_register{$asm_mode}{'pc'}

	.	'|'.$g_regex_register{$asm_mode}{'dn'}
	.	'|'.$g_regex_register{$asm_mode}{'an'}
	.	'|'.$g_regex_register{$asm_mode}{'ssp'}
	.	'|'.$g_regex_register{$asm_mode}{'usp'}
	.	'|'.$g_regex_register{$asm_mode}{'pc'}
	.	'|'.$g_regex_register{$asm_mode}{'sr'}
	.	'|'.$g_regex_register{$asm_mode}{'ccr'}

	.	'|'.$g_regex_register{$asm_mode}{'sfc'}
	.	'|'.$g_regex_register{$asm_mode}{'dfc'}
	.	'|'.$g_regex_register{$asm_mode}{'vbr'}

	.	'|'.$g_regex_register{$asm_mode}{'msp'}
	.	'|'.$g_regex_register{$asm_mode}{'isp'}
	.	'|'.$g_regex_register{$asm_mode}{'cacr'}
	.	'|'.$g_regex_register{$asm_mode}{'caar'}
	.	'|'.$g_regex_register{$asm_mode}{'buscr'}
	.	'|'.$g_regex_register{$asm_mode}{'pcr'}	# 「ぷにぐらま～ずまにゅある 第七版 第二刷」では pc となっていたが pcr に修正した。

	.	'|'.$g_regex_register{$asm_mode}{'crp'}
	.	'|'.$g_regex_register{$asm_mode}{'srp'}
	.	'|'.$g_regex_register{$asm_mode}{'tc'}
	.	'|'.$g_regex_register{$asm_mode}{'ttn'}
	.	'|'.$g_regex_register{$asm_mode}{'mmusr'}
	.	'|'.$g_regex_register{$asm_mode}{'psr'}

	.	'|'.$g_regex_register{$asm_mode}{'urp'}
	.	'|'.$g_regex_register{$asm_mode}{'ittn'}
	.	'|'.$g_regex_register{$asm_mode}{'dttn'}
	.	'|'.$g_regex_register{$asm_mode}{'nc'}
	.	'|'.$g_regex_register{$asm_mode}{'dc'}
	.	'|'.$g_regex_register{$asm_mode}{'ic'}
	.	'|'.$g_regex_register{$asm_mode}{'bc'}

	.	'|'.$g_regex_register{$asm_mode}{'drp'}
	.	'|'.$g_regex_register{$asm_mode}{'cal'}
	.	'|'.$g_regex_register{$asm_mode}{'val'}
	.	'|'.$g_regex_register{$asm_mode}{'scc'}
	.	'|'.$g_regex_register{$asm_mode}{'ac'}
	.	'|'.$g_regex_register{$asm_mode}{'pcsr'}
	.	'|'.$g_regex_register{$asm_mode}{'badn'}
	.	'|'.$g_regex_register{$asm_mode}{'bacn'}

	.	'|'.$g_regex_register{$asm_mode}{'fpn'}
	.	'|'.$g_regex_register{$asm_mode}{'fpcr'}
	.	'|'.$g_regex_register{$asm_mode}{'fpsr'}
	.	'|'.$g_regex_register{$asm_mode}{'fpiar'}
	.	')';

	# movem レジスタリストにマッチする正規表現
	$g_regex_register{$asm_mode}{'movem_reg_list'} =
		'(?:'
	.		'(?:'
	.			$g_regex_register{$asm_mode}{'dn'}
	.		'|'.$g_regex_register{$asm_mode}{'an'}
	.		')'
	.		'(?:'
	.			'[\/\-]'
	.			'(?:'
	.				$g_regex_register{$asm_mode}{'dn'}
	.			'|'.$g_regex_register{$asm_mode}{'an'}
	.			')'
	.		')*'
	.	')';

	# fmovem レジスタリストにマッチする正規表現
	$g_regex_register{$asm_mode}{'fmovem_reg_list'} =
		'(?:'
	.		$g_regex_register{$asm_mode}{'fpn'}
	.		'(?:'
	.			'[\/\-]'
	.			$g_regex_register{$asm_mode}{'fpn'}
	.		')*'
	.	')';
}
if (0) {
	use Data::Dumper;
	print Dumper(\%g_regex_register);
	exit(0);
}


# インストラクションのアドレッシングの引数（Dn An PC d bd address）にマッチする正規表現
my %g_regex_addressing_arg;
foreach my $asm_mode (@g_asm_modes) {
	$g_regex_addressing_arg{$asm_mode} =
		'(?:'
	.		$g_regex_register{$asm_mode}{'all'}
	.	'|'.$g_regex_register{$asm_mode}{'xi'}
	.	'|'.$g_regex_expression{$asm_mode}
	.	')';
}

# 引数解析～コンバータ適用
{
	# 引数解析結果
	my $input_file_name;
	my $output_file_name;
	my $cpu_type = '68000';
	my $force_include_file_name_list;
	my $inline_asm_syntax = 'has';

	# 引数カウント
	my $argc = @ARGV;

	# 引数なしで起動した場合はヘルプを表示して終了
	if ($argc == 0) {
		print	''
		."\n".	'x68k_gcc_has_converter'
		."\n".	'Copyright (C) 2022 Yosshin(@yosshin4004)'
		."\n".	''
		."\n".	'This is a converter translates asm sources generated by m68k-elf-gcc'
		."\n".	'into a format that processible by HAS.X (X68K High-Speed Assembler by'
		."\n".	'Y.Nakamura(YuNK)) and HAS060.X (68060 extended by M.Kamada).'
		."\n".	''
		."\n".	'[usage]'
		."\n".	'	perl x68k_gcc_has_converter.pl [options]'
		."\n".	''
		."\n".	'	options:'
		."\n".	'		-i <input filename>'
		."\n".	'		-o <output filename>'
		."\n".	'		-cpu <CPU type (default is 68000)>'
		."\n".	'		-inc <comma-sepalated force include filename list>'
		."\n".	'		-inline-asm-syntax <specify gas or has as a syntax for inline asm (default is has)>'
		."\n".	''
		."\n";
		exit(EXIT_SUCCESS);
	}

	# オプション解析
	my $iArg = 0;
	while ($iArg < $argc) {
		# オプション指定を検出
		if ($ARGV[$iArg] =~ /^-/) {
			# 入力ファイル指定？
			if ($ARGV[$iArg] eq "-i") {
				# 引数取得
				$iArg++;
				if ($iArg >= $argc) {
					print "ERROR : Argument for " . $ARGV[$iArg - 1] . " is not specified.\n";
					exit(EXIT_FAILURE);
				}
				$input_file_name = $ARGV[$iArg];
			}
			# 出力ファイル指定？
			elsif ($ARGV[$iArg] eq "-o") {
				# 引数取得
				$iArg++;
				if ($iArg >= $argc) {
					print "ERROR : Argument for " . $ARGV[$iArg - 1] . " is not specified.\n";
					exit(EXIT_FAILURE);
				}
				$output_file_name = $ARGV[$iArg];
			}
			# CPU タイプ指定？
			elsif ($ARGV[$iArg] eq "-cpu") {
				# 引数取得
				$iArg++;
				if ($iArg >= $argc) {
					print "ERROR : Argument for " . $ARGV[$iArg - 1] . " is not specified.\n";
					exit(EXIT_FAILURE);
				}
				$cpu_type = $ARGV[$iArg];
			}
			# 強制 include ファイル
			elsif ($ARGV[$iArg] eq "-inc") {
				# 引数取得
				$iArg++;
				if ($iArg >= $argc) {
					print "ERROR : Argument for " . $ARGV[$iArg - 1] . " is not specified.\n";
					exit(EXIT_FAILURE);
				}
				if ($force_include_file_name_list ne '') {
					$force_include_file_name_list .= ',';
				}
				$force_include_file_name_list .= $ARGV[$iArg];
			}
			# inline アセンブラ内の構文
			elsif ($ARGV[$iArg] eq "-inline-asm-syntax") {
				# 引数取得
				$iArg++;
				if ($iArg >= $argc) {
					print "ERROR : Argument for " . $ARGV[$iArg - 1] . " is not specified.\n";
					exit(EXIT_FAILURE);
				}
				$inline_asm_syntax = $ARGV[$iArg];
			}
			# いずれも該当しないなら不正な引数
			else {
				print "ERROR : Invalid option " . $ARGV[$iArg] . " is specified.\n";
				exit(EXIT_FAILURE);
			}
		} else {
			# 不正な引数
			print "ERROR : Invalid option " . $ARGV[$iArg] . " is specified.\n";
			exit(EXIT_FAILURE);
		}

		# 次の要素へ
		$iArg++;
	}

	# 引数が足りないならエラー
	if ($input_file_name eq '') {
		print "ERROR : Input filename is not specified.\n";
		exit(EXIT_FAILURE);
	}
	if ($output_file_name eq '') {
		print "ERROR : Output filename is not specified.\n";
		exit(EXIT_FAILURE);
	}

	# コンバータ適用
	apply_converter($input_file_name, $output_file_name, $cpu_type, $force_include_file_name_list, $inline_asm_syntax);
}

exit(EXIT_SUCCESS);



#------------------------------------------------------------------------------
#	コンバータを適用する
#
#	[parameters]
#		・$input_file_name
#			入力ファイル名
#
#		・$output_file_name
#			出力ファイル名
#
#		・$cpu_type
#			CPU タイプ
#
#		・$force_include_file_name_list
#			強制 include ファイル名リスト（カンマ区切り）
#
#		・$inline_asm_syntax
#			inline asm 内の構文
#
#	[return]
#		なし
#------------------------------------------------------------------------------
sub apply_converter {
	my (
		$input_file_name,
		$output_file_name,
		$cpu_type,
		$force_include_file_name_list,
		$inline_asm_syntax,
	) = @_;

	# 処理内容を TTY 出力（デバッグ用途）
	if (DEBUG) {
		print "input_file_name  $input_file_name\n";
		print "output_file_name $output_file_name\n";
	}

	# 出力ファイルオープン
	my $fh_output = IO::File->new($output_file_name, 'w') or die("ERROR : Cannot open [" . $output_file_name . "].\n");

	# 2 パス処理
	#	1 パス目：ラベル置換ルール作成
	#	2 パス目：ラベル置換ルールに従ったコンバートの実行
	for (my $pass = 1; $pass <= 2; $pass++) {
		# ラベル多重定義検出テーブルのクリア
		%g_already_declared_label = ();

		# 入力ファイルオープン
		my $fh_input  = IO::File->new($input_file_name,  'r') or die("ERROR : Cannot open [" . $input_file_name  . "].\n");

		# 2 パス目：冒頭の定型行を出力
		if ($pass == 2) {
			print $fh_output
					'* NO_APP'
			."\n".	'RUNS_HUMAN_VERSION	equ	3'
			."\n".	'	.cpu ' . $cpu_type
			."\n";
			if ($force_include_file_name_list ne '') {
				foreach my $file_name (split(',', $force_include_file_name_list)) {
					print $fh_output '	.include ' . $file_name . "\n";
				}
			}
			print $fh_output
					'* X68 GCC Develop'
			."\n";
		}

		# 入力ファイル全体を一行ずつ修正
		my $line;
		my $line_num;
		my $asm_mode = 'gas';
		while ($line = <$fh_input>) {
			# ソースの位置情報
			$line_num++;
			$g_src_location = $input_file_name . ':' . $line_num;

			# 行末スペースと改行の除去
			#	CR LF なテキストを入力した場合、chomp() では行末改行が
			#	除去しきれない。正規表現で除去する。
			$line =~ s/\s*[\r\n]*$//g;

			# 修正前の行
			my $orig = $line;

			# 修正結果の生成先
			my $modified;

			# 処理内容を TTY 出力（デバッグ用途）
			if (DEBUG) {
				print "$g_src_location pass:$pass:$asm_mode [" . $line . "]\n";
			}

			# next で脱出する想定のスコープ
			{
				# 冒頭からコメント、もしくはスペースと行末コメント？
				if ($line =~ /^($g_regex_comment|\s*$g_regex_end)/i) {
					# NO_APP 行？
					#	ここより先は inline asm の外であると解釈する。
					if    ($line =~ /^\s*\#NO_APP$/i) {
						$asm_mode = 'gas';
						$modified .= '* APP OFF (NO_APP) asm_mode=' . $asm_mode;
					}
					# APP 行？
					#	ここより先は inline asm の中であると解釈する。
					elsif ($line =~ /^\s*\#APP$/i) {
						$asm_mode = $inline_asm_syntax;
						$modified .= '* APP ON (APP) asm_mode=' . $asm_mode;
					}
					next;
				}

				#--------------------------------------------------------------
				# ラベル・シンボル定義
				#--------------------------------------------------------------

				# ラベル定義ディレクティブ行？
				#	.globl <ラベル>
				#	など
				if (
					$line =~ /(\s*)($g_regex_label_definition_directive{$asm_mode})(\s+)(.+?)$g_regex_end/i
				) {
					my $spaces1		= $1;
					my $directive	= $2;
					my $spaces2		= $3;
					my $label		= $4;
					my $modified_label = modify_label($label, $asm_mode);

					# GAS の .weak は HAS 形式では .globl に置き換える
					if ($asm_mode eq 'gas'
					&&	$directive eq '.weak'
					) {
						$directive = '.globl';
					}

					# GAS の .extern は HAS 形式では .xref に置き換える
					if ($asm_mode eq 'gas'
					&&	$directive eq '.extern'
					) {
						$directive = '.xref';
					}

					# 既出？
					if (exists($g_already_declared_label{$label})) {
						# 矛盾があるならエラー
						if ($g_already_declared_label{$label} ne $directive) {
							die("$g_src_location: ERROR: apply_converter failed. [$label] is already declared as $directive.\n");
						}

						# 矛盾がない場合はエラーとはしない。
						# そして HAS 上で多重定義と見なされるので削除する。
						print "$g_src_location: WARNING: delete duplicated $line\n";

					} else {
						# 既出にする
						$g_already_declared_label{$label} = $directive;

						# GAS の .local は HAS 形式でも必要。
						# これを省略すると、comm ディレクティブで宣言されるシンボルが、
						# 置換ルールに登録されない。
						if ($asm_mode eq 'gas'
						&&	$directive ne '.local'
						) {
							$modified .= $spaces1 . $directive . $spaces2 . $modified_label;
						}

						# 1 パス目：シンボルデータベースにラベル置換ルールを登録
						if ($pass == 1) {
							symbol_db_register_label($label, $modified_label);
						}

						# X68K gcc は main() があるとき .xdef _main と .xref __main を出力する。
						# .xref __main を出力しないと、libc のリンクに失敗する。
						# 参考 https://twitter.com/kamadox/status/1477648323184312324
						if ($label eq 'main') {
							$modified =
								"	.xref __main	* workaround for libc.\n"
							.	$modified;
						}
					}

					next;
				}
				# GAS のシンボル定義ディレクティブ行？
				#		.set <シンボル>, <値>
				elsif (
					$asm_mode eq 'gas'
				&&	$line =~ /^(\s*)(\.set)(\s+)(.+?)$g_regex_end/i
				) {
					my $spaces1		= $1;
					my $directive	= $2;
					my $spaces2		= $3;
					my $arg_list	= $4;
					$arg_list = modify_arg_list($arg_list, $asm_mode);
					my @args = split(',', $arg_list);
					if (@args != 2) {
						die("$g_src_location: ERROR: apply_converter failed to parse [$line].\n");
					}
					my $symbol = $args[0];
					my $value  = $args[1];
					$modified .= $symbol . '=' . $value;
					if ($pass == 1) {
						symbol_db_register_symbol($symbol);
					}
					next;
				}
				# HAS のシンボル定義ディレクティブ行？
				#	<シンボル> <ディレクティブ> <式>
				elsif (
					$asm_mode eq 'has'
				&&	$line =~ /^(\s*)($g_regex_label_and_symbol)(\s+)($g_regex_symbol_definition_directive{$asm_mode})(\s+)(.+?)$g_regex_end/i
				) {
					my $spaces1		= $1;
					my $symbol		= $2;
					my $spaces2		= $3;
					my $directive	= $4;
					my $spaces3		= $5;
					my $expression	= $6;
					$modified .= $spaces1 . $symbol . $spaces2 . $directive . $spaces3 . modify_expression($expression, $asm_mode);
					if ($pass == 1) {
						symbol_db_register_symbol($symbol);
					}
					next;
				}
				# シンボル定義？
				#	<シンボル> = <式>
				#	HAS では、シンボル の末尾に : がない時、行頭スペースは許可されない。
				#	GAS は詳細仕様不明。
				elsif (
					$line =~ /^($g_regex_label_and_symbol)(\s*)=(\s*)(.+?)$g_regex_end/i
				) {
					my $symbol		= $1;
					my $spaces1		= $2;
					my $spaces2		= $3;
					my $expression	= $4;
					$modified .= $symbol . $spaces1 . '=' . $spaces2 . modify_expression($expression, $asm_mode);
					if ($pass == 1) {
						symbol_db_register_symbol($symbol);
					}
					next;
				}
				# HAS のシンボル定義？
				#	<シンボル> := <式>
				#	HAS では、: で終わるラベル宣言は、行頭にスペースを許可しなければならない。
				#	GAS は詳細仕様不明。
				elsif (
					$asm_mode eq 'has'
				&&	$line =~ /^(\s*)($g_regex_label_and_symbol)(\s*)(\:?\s*\=)(\s*)(.+?)$g_regex_end/i
				) {
					my $spaces1		= $1;
					my $symbol		= $2;
					my $spaces2		= $3;
					my $op			= $4;
					my $spaces3		= $5;
					my $expression	= $6;
					$modified .= $spaces1 . $symbol . $spaces2 . $op . $spaces3 . modify_expression($expression, $asm_mode);
					if ($pass == 1) {
						symbol_db_register_symbol($symbol);
					}
					next;
				}
				# ローカルラベル: 行？
				#	HAS では、: で終わるラベル宣言は、行頭にスペースを許可しなければならない。
				#	GAS は詳細仕様不明。
				if (
					$line =~ /^(\s*)($g_regex_local_label{$asm_mode})(\s*)\:/i
				) {
					$line = $';
					my $spaces1		= $1;
					my $local_label	= $2;
					my $spaces2		= $3;
					$modified .= $spaces1 . $local_label . $spaces2 . ':';
					# 後続の記述を評価不要なら next
					if ($line =~ /^$g_regex_end/i) { next; }
				}
				# ラベル: 行？
				#	HAS では、: で終わるラベル宣言は、行頭にスペースを許可しなければならない。
				#	GAS は詳細仕様不明。
				elsif (
					$line =~ /^(\s*)($g_regex_label_and_symbol)(\s*)\:/i
				) {
					$line = $';
					my $spaces1	= $1;
					my $label	= $2;
					my $spaces2	= $3;
					my $modified_label = modify_label($label, $asm_mode);
					$modified .= $spaces1 . $modified_label . $spaces2 . ':';
					if ($pass == 1) {
						symbol_db_register_label($label, $modified_label);
					}
					# 後続の記述を評価不要なら next
					if ($line =~ /^$g_regex_end/i) { next; }
				}

				#--------------------------------------------------------------
				# マクロ、ループ展開、条件付きアセンブリ
				#--------------------------------------------------------------

				# GAS 固有の機能群
				if ($asm_mode eq 'gas') {
					# GAS のマクロ定義？
					if (
						$line =~ /^(\s*)\.macro(\s+)($g_regex_label_and_symbol)(?:(\s+)(.+?))?$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $spaces2		= $2;
						my $symbol		= $3;
						my $spaces3		= $4;	# 省略可能
						my $arg_list	= $5;	# 省略可能
						$modified .= $symbol . ' .macro ' . $arg_list;

						# シンボルデータベースのスタックを 1 段深くする
						symbol_db_inc_depth();

						# 引数リストをローカルシンボルとして登録
						{
							my @args = split(',', $arg_list);
							foreach (@args) {
								my $arg = $_;
								$arg =~ s/^\s+//g;
								$arg =~ s/\s+$//g;
								symbol_db_register_symbol($arg);
							}
						}
						next;
					}

					# GAS のマクロ定義終了？
					if (
						$line =~ /^(\s*)\.endm$g_regex_end/i
					) {
						my $spaces = $1;
						$modified .= $spaces . '.endm';

						# シンボルデータベースのスタックを 1 段浅くする
						symbol_db_dec_depth();

						next;
					}
				}

				# HAS 固有の機能群
				if ($asm_mode eq 'has') {
					# HAS のマクロ実行？
					#	行頭から始まらない、かつ末尾に : が存在しないなら、
					#	定義済みマクロの実行、もしくはインストラクション、
					#	もしくはディレクティブの展開と見なす。
					if (
						$line =~ /^(\s+)($g_regex_label_and_symbol)(?:(\s+)(.+?))?$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $symbol		= $2;
						my $spaces2		= $3;	# 省略可能
						my $arg_list	= $4;	# 省略可能

						# 既出シンボルか？
						if (symbol_db_exists($symbol)) {
							# インストラクションやディレクティブと同名のシンボルが
							# 定義されている場合、それらを定義済みマクロの実行と
							# 混同するので、除外する。
							if ($symbol !~ $g_regex_motorola_instruction
							&&	$symbol !~ $g_regex_directive{'has'}
							) {
								$modified .= $line;
								next;
							}
						}
					}

					# HAS のマクロ定義？
					if (
						$line =~ /^(\s*)($g_regex_label_and_symbol)(\s+)(\.?macro)(?:(\s+)(.+?))?$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $symbol		= $2;
						my $spaces2		= $3;
						my $directive	= $4;
						my $spaces3		= $5;	# 省略可能
						my $arg_list	= $6;	# 省略可能
						$modified .= $spaces1 . $symbol . $spaces2 . $directive . $spaces3 . $arg_list;
						symbol_db_register_symbol($symbol);

						# シンボルデータベースのスタックを 1 段深くする
						symbol_db_inc_depth();

						# 引数リストをローカルシンボルとして登録
						{
							my @args = split(',', $arg_list);
							foreach (@args) {
								my $arg = $_;
								$arg =~ s/^\s+//g;
								$arg =~ s/\s+$//g;
								symbol_db_register_symbol($arg);
							}
						}
						next;
					}

					# HAS のループ開始？
					if (
						$line =~ /^(\s*)(\.?(?:rept|irpc|irp))(?:(\s+)(.+?))?$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $directive	= $2;
						my $spaces2		= $3;	# 省略可能
						my $arg_list	= $4;	# 省略可能
						$modified .= $spaces1 . $directive . $spaces2 . $arg_list;

						# シンボルデータベースのスタックを 1 段深くする
						symbol_db_inc_depth();

						# irp / irpc は、第一引数をローカルシンボルとして登録
						if ($directive =~ /^\.?(?:irpc|irp)$/) {
							my @args = split(',', $arg_list);
							symbol_db_register_symbol($args[0]);
						}
						next;
					}

					# HAS のマクロ定義およびループ終了？
					if (
						$line =~ /^(\s*)(\.?endm)$g_regex_end/i
					) {
						my $spaces		= $1;
						my $directive	= $2;
						$modified .= $spaces . $directive;

						# シンボルデータベースのスタックを 1 段浅くする
						symbol_db_dec_depth();

						next;
					}

					# HAS の条件付きアセンブリ？
					if (
						$line =~ /^(\s*)($g_regex_conditional_assembly_directive{$asm_mode})(\s+)(.+?)$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $directive	= $2;
						my $spaces2		= $3;
						my $arg_list	= $4;
						$modified .= $spaces1 . $directive . $spaces2 . $arg_list;
						next;
					}

					# HAS の条件付きアセンブリ？（引数無し）
					if (
						$line =~ /^(\s*)($g_regex_conditional_assembly_noarg_directive{$asm_mode})$g_regex_end/i
					) {
						my $spaces1		= $1;
						my $directive	= $2;
						$modified .= $spaces1 . $directive;
						next;
					}
				}

				#--------------------------------------------------------------
				# ディレクティブ・インストラクション
				#--------------------------------------------------------------

				# 2 パス目？
				if ($pass == 2) {
					# ディレクティブ行？
					if    ($line =~ /^\s*$g_regex_directive{$asm_mode}/i) {
						if (DEBUG) {
							print "	modify_directive [$line] as $asm_mode\n";
						}
						$modified .= modify_directive($line, $asm_mode);
						next;
					}
					# インストラクション行？
					elsif ($line =~ /^(\s*)($g_regex_instruction)(?:(\s+)(.+?))?$g_regex_end/i) {
						my $spaces1		= $1;
						my $instruction	= $2;
						my $spaces2		= $3;	# 省略可能
						my $arg_list	= $4;	# 省略可能

						# MIT syntax -> Motorola syntax 変換
						if (exists($g_translate_mit_to_motorola{$instruction})) {
							$instruction = $g_translate_mit_to_motorola{$instruction};
							$line = $spaces1 . $instruction . $spaces2 . $arg_list;
						}

						if (DEBUG) {
							print "	modify_instruction [$line] as $asm_mode\n";
						}
						$modified .= modify_instruction($line, $asm_mode);
						next;
					}
					# 上記いずれにも該当しないならエラー
					else {
						die("$g_src_location: ERROR: apply_converter failed to parse [$line] as $asm_mode.\n");
					}
				}
			}	# next; でここを抜ける

			# 2 パス目：コンバート結果の出力
			if ($pass == 2) {
				# 変換前の記述（長すぎると HAS がエラーを起こすので分割）
				my @split_origs = split_string($orig, 128);
				my $num_split_origs = @split_origs;

				# 変換前の記述をコメントとして付加
				{
					# 変換前の記述 1 行目
					my $columns = calc_columns($modified);
					while ($columns < 48) {
						$columns += 8;
						$modified .= '	';
					}
					$modified .= '	*' . $split_origs[0];

					# 変換前の記述 2 行目以降
					for (my $i = 1; $i < $num_split_origs; $i++) {
						$modified .= '							*		' . $split_origs[$i];
					}
				}

				# ファイルに書き出す
				print $fh_output $modified . "\n";
			}
		}

		# 入力ファイルクローズ
		$fh_input ->close;
	}

	# 出力ファイルクローズ
	$fh_output->close;
}


#------------------------------------------------------------------------------
#	10 進数に正規化
#
#	[parameters]
#		・$val
#			10 進数、もしくは 16 進数文字列
#
#	[return]
#		10 進数の値
#------------------------------------------------------------------------------
sub normalize_to_dec {
	my (
		$val
	) = @_;

	# 視認性向上のために挿入されている _ を除去する
	#	0x1234_5678 -> 0x12345678
	#	0b0101_0101 -> 0b01010101
	#	等々
	$val =~ s/_//gi;

	# 16 進数？
	if    ($val =~ /^$g_regex_hex$/i) {
		# $ から始まる 16 進数は、0x から始まる 16 進数に置き換える。
		$val =~ s/^\$/0x/gi;

		# 16 進数 -> 10 進数変換
		$val = hex($val);
	}
	# 8 進数？
	elsif ($val =~ /^$g_regex_oct$/i) {
		# @ から始まる 8 進数は、0o から始まる 8 進数に置き換える。
		$val =~ s/^\@/0o/gi;

		# 8 進数 -> 10 進数変換
		$val = oct($val);
	}
	# 2 進数？
	elsif ($val =~ /^$g_regex_bin$/i) {
		# % から始まる 2 進数は、0b から始まる 2 進数に置き換える。
		$val =~ s/^\%/0b/gi;

		# 2 進数 -> 10 進数変換
		#	oct に 0b から始まる文字列を与えると 2 進数 -> 10 進数変換が行われる。
		$val = oct($val);
	}
	# 10 進数？
	elsif ($val =~ /^$g_regex_dec$/i) {
		# 加工する必要はない
	}

	return $val;
}


#------------------------------------------------------------------------------
#	movem 命令のレジスタマスク値のビット並びを反転する
#
#	[parameters]
#		・$mask
#			レジスタマスク値
#
#	[return]
#		レジスタマスク値のビット並び反転結果
#------------------------------------------------------------------------------
sub reverse_movem_mask {
	my (
		$mask
	) = @_;
	$mask = normalize_to_dec($mask);
	my $reverse_mask = 0;
	for (my $i = 0; $i < 16; $i++) {
		if ($mask & (1 << (15 - $i))) {
			$reverse_mask |= 1 << $i;
		}
	}
	return $reverse_mask;
}


#------------------------------------------------------------------------------
#	fmovem 命令のレジスタマスク値のビット並びを反転する
#
#	[parameters]
#		・$mask
#			レジスタマスク値
#
#	[return]
#		レジスタマスク値のビット並び反転結果
#------------------------------------------------------------------------------
sub reverse_fmovem_mask {
	my (
		$mask
	) = @_;
	$mask = normalize_to_dec($mask);
	my $reverse_mask = 0;
	for (my $i = 0; $i < 8; $i++) {
		if ($mask & (1 << (7 - $i))) {
			$reverse_mask |= 1 << $i;
		}
	}
	return $reverse_mask;
}


#------------------------------------------------------------------------------
#	movem 命令のレジスタマスク値を HAS 形式のレジスタリストに変換
#
#	[parameters]
#		・$mask
#			レジスタマスク値
#
#	[return]
#		HAS 形式のレジスタリスト
#------------------------------------------------------------------------------
sub convert_movem_mask_to_reg_list {
	my (
		$mask
	) = @_;
	$mask = normalize_to_dec($mask);
	my $reg_list;
	for (my $i = 0; $i < 16; $i++) {
		if ($mask & (1 << $i)) {
			if ($reg_list ne ''){ $reg_list .= '/' ;}
			if ($i < 8) {
				$reg_list .= 'd' . ($i & 7);
			} else {
				$reg_list .= 'a' . ($i & 7);
			}
		}
	}
	return $reg_list;
}


#------------------------------------------------------------------------------
#	fmovem 命令のレジスタマスク値を HAS 形式のレジスタリストに変換
#
#	[parameters]
#		・$mask
#			レジスタマスク値
#
#	[return]
#		HAS 形式のレジスタリスト
#------------------------------------------------------------------------------
sub convert_fmovem_mask_to_reg_list {
	my (
		$mask
	) = @_;
	$mask = normalize_to_dec($mask);
	my $reg_list;

	# マスクのビット並びが movem とは逆配置になる。

	for (my $i = 0; $i < 8; $i++) {
		if ($mask & (1 << (7 - $i))) {
			if ($reg_list ne ''){ $reg_list .= '/' ;}
			$reg_list .= 'fp' . $i;
		}
	}
	return $reg_list;
}


#------------------------------------------------------------------------------
#	ディレクティブ行を修正する
#
#	[parameters]
#		・$line
#			ディレクティブ行
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のディレクティブ
#------------------------------------------------------------------------------
sub modify_directive {
	my (
		$line,
		$asm_mode
	) = @_;
	my $modified;

	# GAS モードの場合
	if ($asm_mode eq 'gas') {
		# バイナリ埋め込み
		#	GAS
		#		.long	123, ...
		#		.word	123, ...
		#		.short	123, ...
		#		.byte	123, ...
		#	HAS
		#		.dc.l	123, ...
		#		.dc.w	123, ...
		#		.dc.b	123, ...
		if    ($line =~ /^(\s*)\.long(\s+)(.+?)$g_regex_end/i) {
			# static コンストラクタ
			#	GAS
			#		.long	_GLOBAL__sub_I_func.cpp
			#	HAS
			#		.dc.l	__GLOBAL__sub_I_func?cpp
			#	ちなみに、デストラクタはコンストラクタ内で atexit で登録されるので、
			#	対処する必要はない。
			if    ($line =~ /^(\s*)\.long(\s+)(_GLOBAL_.+?)$g_regex_end/i) {
				my $spaces1		= $1;
				my $spaces2		= $2;
				my $arg_list	= $3;
				$modified = $spaces1 . '.ctor' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
			} else {
				my $spaces1		= $1;
				my $spaces2		= $2;
				my $arg_list	= $3;
				$modified = $spaces1 . '.dc.l' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
			}
		}
		elsif ($line =~ /^(\s*)\.(?:word|short)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			$modified = $spaces1 . '.dc.w' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		elsif ($line =~ /^(\s*)\.byte(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			$modified = $spaces1 . '.dc.b' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# 文字列リテラル
		#	GAS
		#		.string	"ABC"
		#	HAS
		#		.dc.b $41,$42,$43,$00	（末端に \0 が付加される）
		# 注：0 バイト長文字列を認識する必要がある。エスケープシーケンスを考慮する。
		elsif ($line =~ /^(\s*)\.string(\s+)\"((?:\\.|[^\\])*?)\"$g_regex_end/is) {
			my $spaces1	= $1;
			my $spaces2	= $2;
			my $string	= $3;
			$modified = convert_string_to_dump($string);
		}
		# 文字列リテラル
		#	GAS
		#		.ascii "\b\007\009"
		#	HAS
		#		.dc.b $08,$07,$09	（末端に \0 が付加されない）
		# 注：0 バイト長文字列を認識する必要がある。エスケープシーケンスを考慮する。
		elsif ($line =~ /^(\s*)\.ascii(\s+)\"((?:\\.|[^\\])*)\"$g_regex_end/i) {
			my $spaces1	= $1;
			my $spaces2	= $2;
			my $string	= $3;
			$modified = convert_ascii_to_dump($string);
		}
		# .comm ディレクティブ
		#	GAS
		#			.comm	<label>,<size>,<align>
		#	HAS
		#			.comm	<label>,<size>
		elsif ($line =~ /(\s*)\.comm(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;

			my @args = split_and_strip_arg_list($arg_list);
			my $num_args = @args;
			# 3 引数？
			if    ($num_args == 3) {
				# 引数 <align> は .align 命令に分離する。
				# <align> == 1 の時もエラーになるので回避が必要。
				$arg_list = $args[0] . ',' . $args[1];
				if ($args[2] != 1) {
					$modified = $spaces1 . '.align ' . $args[2] . "	* workaround for 3 args .comm directive.\n";
				}
				$modified .= $spaces1 . '.comm' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
			}
			# 2 引数？
			elsif ($num_args == 2) {
				$modified = $spaces1 . '.comm' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
			}
			# 上記いずれにも該当しないならエラー
			else {
				die("$g_src_location: ERROR: modify_directive failed to parse [$line] as $asm_mode.\n");
			}
		}
		# .zero ディレクティブ
		#	GAS
		#		.zero	<size>
		#	HAS
		#		.ds.b	<size>
		elsif ($line =~ /(\s*)\.zero(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			$modified = $spaces1 . '.ds.b' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# TEXT セクションの開始
		#	GAS
		#		.section	.text.startup,"ax",@progbits
		#		等々。
		#		.text に後続する文字列は様々なバリエーションがあるようだ。
		#	HAS
		#		.text
		elsif ($line =~ /(\s*)\.section(\s+)\.text(\..*)?$g_regex_end/i) {
			my $spaces1 = $1;
			my $spaces2 = $2;
			$modified = $spaces1 . '.text';
		}
		# DATA セクションの開始
		#	GAS
		#		.data
		#		.section	.rodata
		#		.section	.rodata.str1.1
		#		等々
		#		.rodata に後続する文字列は様々なバリエーションがあるようだ。
		#	HAS
		#		.data
		elsif ($line =~ /(\s*)\.section(\s+)\.data(\..*)?$g_regex_end/i) {
			my $spaces1 = $1;
			my $spaces2 = $2;
			$modified = $spaces1 . '.data';
		}
		elsif ($line =~ /(\s*)\.section(\s+)\.rodata(\..*)?$g_regex_end/i) {
			my $spaces1 = $1;
			my $spaces2 = $2;
			$modified = $spaces1 . '.data';
		}
		# BSS セクションの開始
		#	GAS
		#		.section	.bss
		#		.text や .rodata と同様に .bss に後続文字列が存在する可能性を考慮する。
		#	HAS
		#		.bss
		elsif ($line =~ /(\s*)\.section(\s+)\.bss(\..*)?$g_regex_end/i) {
			my $spaces1 = $1;
			my $spaces2 = $2;
			$modified = $spaces1 . '.bss';
		}
		# アライメントの指定
		#	GAS
		#		.align <align>
		#	HAS
		#		.align <align>
		elsif ($line =~ /^(\s*)\.align(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			$modified = $spaces1 . '.align' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# アライメントの指定
		#	GAS
		#		.balignw <align>,<value>
		#	HAS
		#		.align <align>,<value>
		elsif ($line =~ /^(\s*)\.balignw(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			$modified = $spaces1 . '.align' . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# ソースファイル名指定
		#	GAS
		#		.file "filename"
		#	HAS
		#		.file "filename"
		elsif ($line =~ /^(\s*)\.file(\s+)\"(.*)\"$g_regex_end/i) {
			my $spaces1	= $1;
			my $spaces2	= $2;
			my $string	= $3;
			$modified = $spaces1 . '.file' . $spaces2 . '"' . $string . '"';
		}
		# 引数有り end
		#	GAS
		#		.end __main
		#	HAS
		#		.end __main
		# 注：引数無し end は、HAS 互換ディレクティブとして別途処理される。
		elsif ($line =~ /^(\s*)(\.(?:end))(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			my $spaces2		= $3;
			my $arg_list	= $4;
			$modified = $spaces1 . $directive . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# HAS と互換のある、引数無しディレクティブ
		elsif ($line =~ /^(\s*)(\.(?:text|data|even|end))$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			$modified = $spaces1 . $directive;
		}
		# 番号付きソースファイル名指定は除去
		#	GAS
		#		.file 1 "filename"
		elsif ($line =~ /^(\s*)\.file(\s+)(\d+)(\s+)\"(.*)\"$g_regex_end/i) {
			my $spaces1	= $1;
			my $spaces2	= $2;
			my $arg1	= $3;
			my $spaces3	= $3;
			my $string	= $4;
			# 何も行わない
		}
		# ソースコード位置情報は除去
		#	GAS
		#		.loc 1 71 2 view .LVU114
		#		.loc 1 106 2 is_stmt 1 view .LVU115
		#		等々
		elsif ($line =~ /^(\s*)\.loc(\s+)(.*)$g_regex_end/i) {
			my $spaces1		= $1;
			my $spaces2		= $2;
			my $arg_list	= $3;
			# 何も行わない
		}
		# HAS が認識できないディレクティブの除去
		#	.hidden		複数ファイルにまたがって参照されるが非公開にしたいラベル
		#	.type		ラベルの用途を指定するデバッグ情報らしい
		#	.size		デバッグ情報らしい
		#	.ident		コンパイラのバージョン情報らしい
		#	.section	必要なものは個別に認識済み
		#	.swbeg		詳細不明
		#	.cfi_...	デバッグ情報らしい
		elsif ($line =~ /^(\s*)(\.(?:hidden|type|size|ident|section|swbeg|cfi_\w+))(?:(\s+)(.+?))?$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			my $spaces2		= $3;	# 省略可能
			my $arg_list	= $4;	# 省略可能
			# 何も行わない
		}
		# 上記いずれにも該当しないならエラー
		else {
			die("$g_src_location: ERROR: modify_directive failed to parse [$line] as $asm_mode.\n");
		}
	}
	# HAS モードの場合
	#	注意：HAS の場合、ディレクティブの先頭の . が省略されることを想定。
	elsif ($asm_mode eq 'has') {
		# .include <ファイル名>
		# .insert <ファイル名>
		#	このディレクティブの引数はファイル名であり、加工してはいけない。
		if	  ($line =~ /^(\s*)(\.?(?:include|insert))(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			my $spaces2		= $3;
			my $filename	= $4;
			$modified = $spaces1 . $directive . $spaces2 . $filename;
		}
		# .request <ファイル名>[,<ファイル名>…]
		#	このディレクティブの引数はファイル名であり、加工してはいけない。
		elsif ($line =~ /^(\s*)(\.?request)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			my $spaces2		= $3;
			my $filenames	= $4;
			$modified = $spaces1 . $directive . $spaces2 . $filenames;
		}
		# その他のディレクティブ
		#	ディレクティブ自体は変換不要だが、オペランドは修正する必要がある。
		elsif ($line =~ /^(\s*)($g_regex_directive{$asm_mode})(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $directive	= $2;
			my $spaces2		= $3;
			my $arg_list	= $4;
			$modified = $spaces1 . $directive . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# その他のディレクティブ（引数無し）
		elsif ($line =~ /^(\s*)($g_regex_directive{$asm_mode})$g_regex_end/i) {
			my $spaces		= $1;
			my $directive	= $2;
			$modified = $spaces . $directive;
		}
		# 上記いずれにも該当しないならエラー
		else {
			die("$g_src_location: ERROR: modify_directive failed to parse [$line] as $asm_mode.\n");
		}
	}
	# 不明なモードならエラー
	else {
		die("$g_src_location: ERROR: unknown asm_mode [$asm_mode].\n");
	}

	return $modified;
}


#------------------------------------------------------------------------------
#	インストラクション行を修正する
#
#	[parameters]
#		・$line
#			インストラクション行
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のインストラクション
#------------------------------------------------------------------------------
sub modify_instruction {
	my (
		$line,
		$asm_mode
	) = @_;
	my $modified;

	# GAS モードの場合
	if ($asm_mode eq 'gas') {
		# movem 命令（プレデクリメントモード）
		#	GAS
		#		Motrola syntax
		#			movem.l #15360,-(an)
		#		MIT syntax
		#			movem.l #15360,%an@-
		#	HAS
		#		movem.l d3/d4/d5/a3/a4,-(an)
		if    ($line =~ /^(\s*)(movem$g_regex_opsize?)(\s+)\#($g_regex_int)(\s*),(\s*)(-\($g_regex_register{$asm_mode}{'an'}\)|$g_regex_register{$asm_mode}{'an'}\@-)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $mask		= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $dst			= $7;
			$modified = $spaces1 . $instruction . $spaces2 . convert_movem_mask_to_reg_list(reverse_movem_mask($mask)) . $spaces3 . ',' . $spaces4 . modify_arg_list($dst, $asm_mode);
		}
		# movem 命令（制御・可変モード）
		#	GAS
		#		movem.l #15360,<ea>
		#	HAS
		#		movem.l d3/d4/d5/a3/a4,<ea>
		# プレデクリメントモードと誤判定されることを避けるため優先順位を下げている
		elsif ($line =~ /^(\s*)(movem$g_regex_opsize?)(\s+)\#($g_regex_int)(\s*),(\s*)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $mask		= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $dst			= $7;
			$modified = $spaces1 . $instruction . $spaces2 . convert_movem_mask_to_reg_list($mask) . $spaces3 . ',' . $spaces4 . modify_arg_list($dst, $asm_mode);
		}
		# movem 命令
		#	GAS
		#		movem.l <ea>,#1148
		#	HAS
		#		movem.l <ea>,d2/d3/d4/d5/d6/a2
		elsif ($line =~ /^(\s*)(movem$g_regex_opsize?)(\s+)(.+)(\s*),(\s*)\#($g_regex_int)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $src			= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $mask		= $7;
			$modified = $spaces1 . $instruction . $spaces2 . modify_arg_list($src, $asm_mode) . $spaces3 . ',' . $spaces4 . convert_movem_mask_to_reg_list($mask);
		}
		# fmovem 命令（プレデクリメントモード）
		#	GAS
		#		Motrola syntax
		#			fmovem #0x3f,-(an)
		#		MIT syntax
		#			fmovem #0x3f,%an@-
		#	HAS
		#		fmovem.l fp0/fp1/fp2/fp3/fp4/fp5,-(an)
		elsif ($line =~ /^(\s*)(fmovem$g_regex_opsize?)(\s+)\#($g_regex_int)(\s*),(\s*)(-\($g_regex_register{$asm_mode}{'an'}\)|$g_regex_register{$asm_mode}{'an'}\@-)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $mask		= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $dst			= $7;
			$modified = $spaces1 . $instruction . $spaces2 . convert_fmovem_mask_to_reg_list(reverse_fmovem_mask($mask)) . $spaces3 . ',' . $spaces4 . modify_arg_list($dst, $asm_mode);
		}
		# fmovem 命令（制御・可変モード）
		#	GAS
		#		fmovem #0xfc,<ea>
		#	HAS
		#		fmovem fp0/fp1/fp2/fp3/fp4/fp5,<ea>
		# プレデクリメントモードと誤判定されることを避けるため優先順位を下げている
		elsif ($line =~ /^(\s*)(fmovem$g_regex_opsize?)(\s+)\#($g_regex_int)(\s*),(\s*)([^-].+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $mask		= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $dst			= $7;
			$modified = $spaces1 . $instruction . $spaces2 . convert_fmovem_mask_to_reg_list($mask) . $spaces3 . ',' . $spaces4 . modify_arg_list($dst, $asm_mode);
		}
		# fmovem 命令
		#	GAS
		#		fmovem.l <ea>,#0xfc
		#	HAS
		#		fmovem.l <ea>,fp0/fp1/fp2/fp3/fp4/fp5
		elsif ($line =~ /^(\s*)(fmovem$g_regex_opsize?)(\s+)(.+)(\s*),(\s*)\#($g_regex_int)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $src			= $4;
			my $spaces3		= $5;
			my $spaces4		= $6;
			my $mask		= $7;
			$modified = $spaces1 . $instruction . $spaces2 . modify_arg_list($src, $asm_mode) . $spaces3 . ',' . $spaces4 . convert_fmovem_mask_to_reg_list($mask);
		}
		# jXX 命令
		#	GAS
		#		jhi		jls		jcc		jcs		jne		jeq		jvc
		#		jvs		jpl		jmi		jge		jlt		jgt		jle
		#		jra
		#	HAS
		#		jbhi	jbls	jbcc	jbcs	jbne	jbeq	jbvc
		#		jbvs	jbpl	jbmi	jbge	jblt	jbgt	jble
		#		jbra
		#
		# HAS では、jcc と bcc を自動選択できる jbcc が使える。
		elsif ($line =~ /^(\s*)j(hi|ls|cc|cs|ne|eq|vc|vs|pl|mi|ge|lt|gt|le|ra)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $condition	= $2;
			my $spaces2		= $3;
			my $dst			= $4;
			$modified = $spaces1 . 'jb' . $condition . $spaces2 . modify_arg_list($dst, $asm_mode);
		}
		# fjXX 命令
		#	GAS
		#		fjne   fjeq   fjge   fjlt   fjgt   fjle   fjf
		#		fjt    fjgl   fjgle  fjnge  fjngl  fjngle fjngt
		#		fjnle  fjnlt  fjoge  fjogl  fjogt  fjole  fjolt
		#		fjor   fjseq  fjsf   fjsne  fjst   fjueq  fjuge
		#		fjugt  fjule  fjult  fjun
		#	HAS
		#		fbne   fbeq   fbge   fblt   fbgt   fble   fbf
		#		fbt    fbgl   fbgle  fbnge  fbngl  fbngle fbngt
		#		fbnle  fbnlt  fboge  fbogl  fbogt  fbole  fbolt
		#		fbor   fbseq  fbsf   fbsne  fbst   fbueq  fbuge
		#		fbugt  fbule  fbult  fbun
		#
		# fjbcc のような仕組みは無いようだ。
		# 誤認識を避けるため、文字数の長い方からマッチする必要がある。
		elsif ($line =~ /^(\s*)fj(ngle|gle|nge|ngl|ngt|nlt|oge|ogl|ogt|ole|olt|seq|sne|ueq|uge|nle|ugt|ule|ult|ne|eq|ge|lt|gt|le|gl|or|sf|st|un|f|t)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $condition	= $2;
			my $spaces2		= $3;
			my $dst			= $4;
			$modified = $spaces1 . 'fb' . $condition . $spaces2 . modify_arg_list($dst, $asm_mode);
		}
		# jsr 命令
		#	GAS
		#		jsr
		#	HAS
		#		jbra
		#
		# HAS では、jsr と bsr を自動選択できる jbsr が使える。
		elsif ($line =~ /^(\s*)jsr(\s+)(.+?)$g_regex_end/i) {
			my $spaces1	= $1;
			my $spaces2	= $2;
			my $dst		= $3;
			$modified = $spaces1 . 'jbsr' . $spaces2 . modify_arg_list($dst, $asm_mode);
		}
		# その他の命令
		elsif ($line =~ /^(\s*)($g_regex_instruction)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $arg_list	= $4;
			$modified = $spaces1 . $instruction . $spaces2 . modify_arg_list($arg_list, $asm_mode);
		}
		# その他の命令（引数無し）
		elsif ($line =~ /^(\s*)($g_regex_instruction)$g_regex_end/i) {
			my $spaces		= $1;
			my $instruction	= $2;
			$modified = $spaces . $instruction;
		}
		# 上記いずれにも該当しないならエラー
		else {
			die("$g_src_location: ERROR: modify_instruction failed to parse [$line] as $asm_mode.\n");
		}
	}
	# HAS モードの場合
	elsif ($asm_mode eq 'has') {
		# その他の命令
		#	命令自体は変換不要だが、オペランドは修正する必要がある。
		if    ($line =~ /^(\s*)($g_regex_instruction)(\s+)(.+?)$g_regex_end/i) {
			my $spaces1		= $1;
			my $instruction	= $2;
			my $spaces2		= $3;
			my $arg_list	= $4;

			# HAS モードでも、inline asm の引数として  GAS モードの引数が出現することがある。
			# そのため、まず GAS モードで modify_arg_list したのち、HAS モードで modify_arg_list する
			# 必要がある。
			$modified = $spaces1 . $instruction . $spaces2 . modify_arg_list(modify_register($arg_list, 'gas'), 'has');
		}
		# その他の命令（引数無し）
		elsif ($line =~ /^(\s*)($g_regex_instruction)$g_regex_end/i) {
			my $spaces		= $1;
			my $instruction	= $2;
			$modified = $spaces . $instruction;
		}
		# 上記いずれにも該当しないならエラー
		else {
			die("$g_src_location: ERROR: modify_instruction failed to parse [$line] as $asm_mode.\n");
		}
	}
	# 不明なモードならエラー
	else {
		die("$g_src_location: ERROR: unknown asm_mode [$asm_mode].\n");
	}

	return $modified;
}


#------------------------------------------------------------------------------
#	ラベルを修正する
#
#	[parameters]
#		・$label
#			ラベル
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のラベル
#------------------------------------------------------------------------------
sub modify_label {
	my (
		$label,
		$asm_mode
	) = @_;

	# GAS モードの場合
	if ($asm_mode eq 'gas') {
		#	GAS
		#		abc
		#		abc.def
		#	HAS
		#		_abc
		#		abc?def

		# X68K gcc ではラベル名に出現する . を ? に置換する。
		$label =~ s/\./\?/gi;

		# X68K gcc ではラベル名先頭に _ が付加される。
		$label = '_' . $label;
	}
	# HAS モードの場合
	elsif ($asm_mode eq 'has') {
		# 何も行わない
	}
	# 不明なモードならエラー
	else {
		die("$g_src_location: ERROR: unknown asm_mode [$asm_mode].\n");
	}

	return $label;
}


#------------------------------------------------------------------------------
#	レジスタを修正する
#
#	[parameters]
#		・$register
#			レジスタ
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のレジスタ
#------------------------------------------------------------------------------
sub modify_register {
	my (
		$register,
		$asm_mode
	) = @_;

	# GAS モードの場合
	if ($asm_mode eq 'gas') {
		# レジスタ名とオペランドサイズ表記の修正
		#	GAS では、%d0:l %d1:w %d2:b のような MIT syntax も修正する必要がある。
		#	68020 以降で利用可能なレジスタ省略表記の za0～za7,zd0～zd7,zpc 等にも対応する。

		$register =~ s/%(z?d[0-7])$g_regex_end_of_name\:([bwl])\:([1248])/\1.\2*\3/gi;
		$register =~ s/%(z?a[0-7])$g_regex_end_of_name\:([bwl])\:([1248])/\1.\2*\3/gi;
		$register =~ s/%(z?d[0-7])$g_regex_end_of_name\:([1248])/\1*\2/gi;
		$register =~ s/%(z?a[0-7])$g_regex_end_of_name\:([1248])/\1*\2/gi;
		$register =~ s/%(z?d[0-7])$g_regex_end_of_name\:([bwl])/\1.\2/gi;
		$register =~ s/%(z?a[0-7])$g_regex_end_of_name\:([bwl])/\1.\2/gi;
		$register =~ s/%(z?d[0-7])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(z?a[0-7])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(z?)fp$g_regex_end_of_name/\1a6/gi;
		$register =~ s/%(z?sp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(ssp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(usp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(z?pc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(sr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(ccr)$g_regex_end_of_name/\1/gi;

		$register =~ s/%(sfc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(dfc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(vbr)$g_regex_end_of_name/\1/gi;

		$register =~ s/%(msp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(isp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(cacr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(caar)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(buscr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(pcr)$g_regex_end_of_name/\1/gi;

		$register =~ s/%(crp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(srp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(tc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(tt[0-1])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(mmusr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(psr)$g_regex_end_of_name/\1/gi;

		$register =~ s/%(urp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(itt[0-1])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(dtt[0-1])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(nc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(dc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(ic)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(bc)$g_regex_end_of_name/\1/gi;

		$register =~ s/%(drp)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(cal)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(val)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(scc)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(ac)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(pcsr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(bad[0-7])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(bac[0-7])$g_regex_end_of_name/\1/gi;

		$register =~ s/%(fp[0-7])$g_regex_end_of_name/\1/gi;
		$register =~ s/%(fpcr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(fpsr)$g_regex_end_of_name/\1/gi;
		$register =~ s/%(fpiar)$g_regex_end_of_name/\1/gi;
	}

	return $register;
}


#------------------------------------------------------------------------------
#	ビットフィールドを修正する
#
#	[parameters]
#		・$bitfield
#			ビットフィールド
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のビットフィールド
#------------------------------------------------------------------------------
sub modify_bitfield {
	my (
		$bitfield,
		$asm_mode
	) = @_;

	# GAS モードの場合
	if ($asm_mode eq 'gas') {
		# gas では width に 0 が指定可能だが HAS ではエラーになる。代わりに 32 を指定する。
		if ($bitfield =~ /^\{(?:\#)?($g_regex_int)\:(?:\#)?($g_regex_int)\}$/i) {
			my $offset	= $1;
			my $width	= $2;
			if ($width == 0) {
				$width = 32;
			}
			$bitfield = "{\#$offset:\#$width}";
		}
	}

	return $bitfield;
}


#------------------------------------------------------------------------------
#	アドレッシング引数を修正する
#
#	[parameters]
#		・$arg
#			引数
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式のアドレッシング引数
#------------------------------------------------------------------------------
sub modify_addressing_arg {
	my (
		$arg,
		$asm_mode
	) = @_;
	my $modified;

	# レジスタ？
	if    ($arg =~ /^($g_regex_register{$asm_mode}{'all'})$/i) {
		my $register = $1;
		$modified = modify_register($register, $asm_mode);
	}
	# Xi？
	elsif ($arg =~ /^($g_regex_register{$asm_mode}{'xi'})$/i) {
		my $xi = $1;
		$modified = modify_register($xi, $asm_mode);
	}
	# 式？
	elsif ($arg =~ /^($g_regex_expression{$asm_mode})$/i) {
		my $expression = $1;
		$modified = $expression;
	}
	# 省略？
	elsif ($arg eq '') {
		$modified = '';
	}
	# 上記いずれにも該当しないならエラー
	else {
		die("$g_src_location: ERROR: modify_addressing_arg failed to parse [$arg] as $asm_mode.\n");
	}

	return $modified;
}


#------------------------------------------------------------------------------
#	式を修正する
#
#	[parameters]
#		・$expression
#			式
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式の式
#------------------------------------------------------------------------------
sub modify_expression {
	my (
		$expression,
		$asm_mode
	) = @_;

	# 式を分解＆修正
	my @a_arg = split_and_modify_arg_list($expression, $asm_mode);

	return join(',', @a_arg);
}


#------------------------------------------------------------------------------
#	引数リストを修正する
#
#	[parameters]
#		・$arg_list
#			引数リスト
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式の引数リスト
#------------------------------------------------------------------------------
sub modify_arg_list {
	my (
		$arg_list,
		$asm_mode
	) = @_;
	my @a_modified_arg;

	if (DEBUG) {
		print "		modify_arg_list [" . $arg_list . "]\n";
	}

	# 引数リストを分解＆修正
	my @a_arg = split_and_modify_arg_list($arg_list, $asm_mode);

	# 引数リストを巡回
	foreach (@a_arg) {
		my $arg = $_;

		# 以下のアドレッシングモードをサポートする必要がある。
		#
		#	Dn						ビットフィールド対応
		#	An
		#	(An)					ビットフィールド対応
		#	(An)+
		#	-(An)
		#	d(An)					ビットフィールド対応
		#	d(An,Xi)				ビットフィールド対応
		#	(bd,An,Xi)				ビットフィールド対応
		#	([bd,An],Xi,od)			ビットフィールド対応
		#	([bd,An,Xi],od)			ビットフィールド対応
		#	address(PC)
		#	address(PC,Xi)
		#	(address,PC,Xi)
		#	([address,PC],Xi,od)
		#	([address,PC,Xi],od)
		#	(xxxx).W				ビットフィールド対応
		#	(xxxx).L				ビットフィールド対応
		#	#xxxx
		#
		# 引数は省略可能なため、実際にはもっと多くのバリエーションが存在する。
		# 省略形を含めた全てのパターンを正規表現で認識するのは非常に煩雑である。
		# ここでは問題を単純化するため、以下のようなバリエーションと見なす。
		#
		#	Dn						ビットフィールド対応
		#	An
		#	(An)					ビットフィールド対応
		#	(An)+
		#	-(An)
		#	expression(arg1,arg2)	ビットフィールド対応
		#	expression(arg1)		ビットフィールド対応
		#	(arg1,arg2,arg3)		ビットフィールド対応
		#	(arg1,arg2)				ビットフィールド対応
		#	(arg1)					ビットフィールド対応
		#	([arg1,arg2,arg3],arg4)	ビットフィールド対応
		#	([arg1,arg2,arg3])		ビットフィールド対応
		#	([arg1,arg2],arg3,arg4)	ビットフィールド対応
		#	([arg1,arg2],arg3)		ビットフィールド対応
		#	([arg1,arg2])			ビットフィールド対応
		#	([arg1],arg2,arg3)		ビットフィールド対応
		#	([arg1],arg2)			ビットフィールド対応
		#	([arg1])				ビットフィールド対応
		#	(xxxx).W				ビットフィールド対応
		#	(xxxx).L				ビットフィールド対応
		#	#xxxx
		#
		# arg1～ は、Dn An Xi PC d bd address にマッチするものとする。
		# expression は、d bd address にマッチするものとする。
		# 結果的に曖昧なマッチングになるが、HAS も同様の対応を取っているようなので
		# 問題は無いし、HAS との互換性も向上する。
		#
		#
		# GAS の表記には、MIT syntax と Motorola syntax の二通りが存在する。
		# Motorola syntax は HAS と互換があるが、MIT syntax は互換がない。
		# m68k-elf-gcc は、極まれに MIT syntax を出力する場合がある。
		#
		#										MIT syntax									Motorola syntax
		#	Address Register Indirect			%a0@ ～ %a7@								(%a0) ～ (%a7)
		#	Address Register Postincrement		%a0@+ ～ %a7@+								(%a0)+ ～ (%a7)+
		#	Address Register Predecrement		%a0@- ～ %a7@-								-(%a0) ～ -(%a7)
		#	Indirect Plus Offset				apc@(number)								number(apc)
		#	Index								apc@(number,register:size:scale)			number(apc,register.size*scale)
		#	Postindex							apc@(number)@(onumber,register:size:scale)	([number,apc],register.size*scale,onumber)
		#	Preindex							apc@(number,register:size:scale)@(onumber)	([number,apc,register.size*scale],onumber)
		#	※apc とは、An または PC を意味する。


		# レジスタ
		if    (
			$arg =~ /^($g_regex_register{$asm_mode}{'all'})($g_regex_bitfield)?$/i
		) {
			my $register	= $1;
			my $bitfield	= $2;
			my $modified_arg = modify_register($register, $asm_mode) . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as register\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (An)
		elsif (
			$arg =~ /^\(($g_regex_register{$asm_mode}{'an'})\)($g_regex_bitfield)?$/i
		) {
			my $an			= $1;
			my $bitfield	= $2;
			my $modified_arg = '(' . modify_register($an, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (An)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (An)+
		elsif (
			$arg =~ /^\(($g_regex_register{$asm_mode}{'an'})\)\+$/i
		) {
			my $an = $1;
			my $modified_arg = '(' . modify_register($an, $asm_mode) . ')+';
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (An)+\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# -(An)
		elsif (
			$arg =~ /^\-\(($g_regex_register{$asm_mode}{'an'})\)$/i
		) {
			my $an = $1;
			my $modified_arg = '-(' . modify_register($an, $asm_mode) . ')';
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as -(An)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# expression(arg1,arg2)
		#	arg1,arg2 は省略可能
		elsif (
			$arg =~ /^($g_regex_expression{$asm_mode})\(($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $expression	= $1;
			my $arg1		= $2;
			my $arg2		= $3;
			my $bitfield	= $4;
			my $modified_arg = $expression . '(' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as expression(arg1,arg2)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# expression(arg1)
		elsif (
			$arg =~ /^($g_regex_expression{$asm_mode})\(($g_regex_addressing_arg{$asm_mode})\)($g_regex_bitfield)?$/i
		) {
			my $expression	= $1;
			my $arg1		= $2;
			my $bitfield	= $3;
			my $modified_arg = $expression . '(' . modify_addressing_arg($arg1, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as expression(arg1)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (arg1,arg2,arg3)
		#	arg1,arg2,arg3 は省略可能
		elsif (
			$arg =~ /^\(($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $bitfield	= $4;
			my $modified_arg = '(' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . ',' . modify_addressing_arg($arg3, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (arg1,arg2,arg3)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (arg1,arg2)
		#	arg1,arg2 は省略可能
		elsif (
			$arg =~ /^\(($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $bitfield	= $3;
			my $modified_arg = '(' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (arg1,arg2)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (arg1)
		elsif (
			$arg =~ /^\(($g_regex_addressing_arg{$asm_mode})\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $bitfield	= $2;
			my $modified_arg = '(' . modify_addressing_arg($arg1, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (arg1)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1,arg2,arg3],arg4)
		#	arg1,arg2,arg3,arg4 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\],($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $arg4		= $4;
			my $bitfield	= $5;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . ',' . modify_addressing_arg($arg3, $asm_mode) . '],' . modify_addressing_arg($arg4, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1,arg2,arg3],arg4)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1,arg2,arg3])
		#	arg1,arg2,arg3 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\]\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $bitfield	= $4;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . ',' . modify_addressing_arg($arg3, $asm_mode) . '])' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1,arg2,arg3])\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1,arg2],arg3,arg4)
		#	arg1,arg2,arg3,arg4 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\],($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $arg4		= $4;
			my $bitfield	= $5;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . '],' . modify_addressing_arg($arg3, $asm_mode) . ',' . modify_addressing_arg($arg4, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1,arg2],arg3,arg4)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1,arg2],arg3)
		#	arg1,arg2,arg3 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\],($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $bitfield	= $4;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . '],' . modify_addressing_arg($arg3, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1,arg2],arg3)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1,arg2])
		#	arg1,arg2 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\]\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $bitfield	= $3;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . ',' . modify_addressing_arg($arg2, $asm_mode) . '])' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1,arg2])\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1],arg2,arg3)
		#	arg1,arg2,arg3 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?\],($g_regex_addressing_arg{$asm_mode})?,($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $arg3		= $3;
			my $bitfield	= $4;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . '],' . modify_addressing_arg($arg2, $asm_mode) . ',' . modify_addressing_arg($arg3, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1],arg2,arg3)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1],arg2)
		#	arg1,arg2 は省略可能
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})?\],($g_regex_addressing_arg{$asm_mode})?\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $arg2		= $2;
			my $bitfield	= $3;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . '],' . modify_addressing_arg($arg2, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1],arg2)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# ([arg1])
		elsif (
			$arg =~ /^\(\[($g_regex_addressing_arg{$asm_mode})\]\)($g_regex_bitfield)?$/i
		) {
			my $arg1		= $1;
			my $bitfield	= $2;
			my $modified_arg = '([' . modify_addressing_arg($arg1, $asm_mode) . '])' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as ([arg1])\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# movem レジスタリスト
		#	レジスタリストに 1 要素しかない場合、レジスタ単体指定と区別ができない。
		#	ビットフィールドが後続する場合は、レジスタ単体指定と見なし、マッチをキャンセルする。
		elsif (
			$arg =~ /^($g_regex_register{$asm_mode}{'movem_reg_list'})(?!$g_regex_bitfield)$/i
		) {
			my $reg_list = $1;
			my $modified_arg = modify_register($reg_list, $asm_mode);
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as movem_reg_list\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# fmovem レジスタリスト
		elsif (
			$arg =~ /^($g_regex_register{$asm_mode}{'fmovem_reg_list'})$/i
		) {
			my $reg_list = $1;
			my $modified_arg = modify_register($reg_list, $asm_mode);
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as fmovem_reg_list\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : %an@
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'an'})\@($g_regex_bitfield)?$/i
		) {
			my $an			= $1;
			my $bitfield	= $2;
			my $modified_arg = '(' . modify_register($an, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as %an@\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : %an@+
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'an'})\@\+$/i
		) {
			my $an = $1;
			my $modified_arg = '(' . modify_register($an, $asm_mode) . ')+';
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as %an@+\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : %an@-
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'an'})\@\-$/i
		) {
			my $an = $1;
			my $modified_arg = '-(' . modify_register($an, $asm_mode) . ')';
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as %an@-\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : apc@(number)
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'apc'})\@\(($g_regex_expression{$asm_mode})\)($g_regex_bitfield)?$/i
		) {
			my $apc			= $1;
			my $expression	= $2;
			my $bitfield	= $3;
			my $modified_arg = $expression . '(' . modify_register($apc, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as apc@(number)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : apc@(number,register:size:scale)
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'apc'})\@\(($g_regex_expression{$asm_mode}),($g_regex_register{$asm_mode}{'xi'})\)($g_regex_bitfield)?$/i
		) {
			my $apc			= $1;
			my $expression	= $2;
			my $xi			= $3;
			my $bitfield	= $4;
			my $modified_arg = $expression . '(' . modify_register($apc, $asm_mode) . ',' . modify_register($xi, $asm_mode) . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as apc@(number,register:size:scale)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : apc@(number)@(onumber,register:size:scale)
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'apc'})\@\(($g_regex_expression{$asm_mode})\)\@\(($g_regex_expression{$asm_mode}),($g_regex_register{$asm_mode}{'xi'})\)($g_regex_bitfield)?$/i
		) {
			my $apc			= $1;
			my $expression1	= $2;
			my $expression2	= $3;
			my $xi			= $4;
			my $bitfield	= $5;
			my $modified_arg = '([' . $expression1 . ',' . modify_register($apc, $asm_mode) . '],' . modify_register($xi, $asm_mode) . ',' . $expression2 . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as apc@(number)@(onumber,register:size:scale)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# MIT syntax : apc@(number,register:size:scale)@(onumber)
		elsif (
			$asm_mode eq 'gas'
		&&	$arg =~ /^($g_regex_register{$asm_mode}{'apc'})\@\(($g_regex_expression{$asm_mode}),($g_regex_register{$asm_mode}{'xi'})\)\@\(($g_regex_expression{$asm_mode})\)($g_regex_bitfield)?$/i
		) {
			my $apc			= $1;
			my $expression1	= $2;
			my $xi			= $3;
			my $expression2	= $4;
			my $bitfield	= $5;
			my $modified_arg = '([' . $expression1 . ',' . modify_register($apc, $asm_mode) . ',' . modify_register($xi, $asm_mode) . '],' . $expression2 . ')' . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as apc@(number,register:size:scale)@(onumber)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# #imm
		#	gas では &imm と書くこともある。
		elsif (
			 $arg =~ /^\#($g_regex_expression{$asm_mode})$/i
		||	($arg =~ /^\&($g_regex_expression{$asm_mode})$/i && $asm_mode eq 'gas')
		) {
			my $expression = $1;
			my $modified_arg;

			# 9 桁を超える 16 進数は、8 桁ごとに分割して再帰呼出し
			if ($expression =~ /^0x([0-9a-fA-F]{9,})$/i) {
				my $hex = $1;
				my $split_hex;
				for (my $i = 0; $hex ne ''; $i++) {
					if ($i != 0) {
						$split_hex .= ',';
					}

					# 8 桁まとめて切り出す
					if ($hex =~ /^([0-9a-fA-F]{8})/i) {
						$split_hex .= '#0x' . $1;
						$hex = $` . $';
					}
					# 8 桁未満をまとめて切り出す
					elsif ($hex =~ /^([0-9a-fA-F]{1,7})/i) {
						$split_hex .= '#0x' . $1;
						$hex = $` . $';
					}
					# エラー
					elsif ($hex ne '') {
						die("$g_src_location: ERROR: modify_arg_list failed to parse [$expression] as $asm_mode hex.\n");
					}
				}

				# 再帰呼出し
				$modified_arg = modify_arg_list($split_hex, $asm_mode);
			}
			else {
				$modified_arg = '#' . $expression;
			}

			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as #imm\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# 数値またはラベル名または式
		elsif (
			$arg =~ /^($g_regex_expression{$asm_mode})($g_regex_bitfield)?$/i
		) {
			my $expression	= $1;
			my $bitfield	= $2;
			my $modified_arg = $expression . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as expression\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# (xxxx).W (xxxx).L
		#	(arg1) の一部と誤認識されることを避けるため、先に評価する。
		elsif (
			$arg =~ /^\(($g_regex_expression{$asm_mode})\)($g_regex_opsize)?($g_regex_bitfield)?$/i
		) {
			my $expression	= $1;
			my $opsize		= $2;
			my $bitfield	= $3;
			my $modified_arg = '(' . $expression . ')' . $opsize . $bitfield;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (expression)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# 文字列リテラル
		elsif (
			$arg =~ /^($g_regex_string_literal)/i
		) {
			my $string_literal = $1;
			my $modified_arg = $string_literal;
			if (DEBUG) {
				print "			arg [$arg -> $modified_arg] as (string literal)\n";
			}
			push(@a_modified_arg, $modified_arg);
		}
		# 上記いずれにも該当しないならエラー
		else {
			die("$g_src_location: ERROR: modify_arg_list failed to parse [$arg_list] as $asm_mode.\n");
		}
	}

	# 修正引数リストの結合
	my $modified_arg = join(',', @a_modified_arg);
	return $modified_arg;
}


#------------------------------------------------------------------------------
#	引数リストを分解＆修正する
#
#	[parameters]
#		・$arg_list
#			引数リスト
#
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		HAS 形式の引数配列
#
#	[remarks]
#		ビットフィールドの修正と、ラベル置換が適用される。
#------------------------------------------------------------------------------
sub split_and_modify_arg_list {
	my (
		$arg_list,
		$asm_mode
	) = @_;
	my @a_split_arg;
	my $orig = $arg_list;

	# 括弧のネスト認識用スタック 
	my @a_stack;

	# 引数分解結果
	my $arg;

	# 直前のステート
	my $state = '';

	# 行末コメントとスペースを除去
	$arg_list =~ s/$g_regex_line_end_comment//gi;
	$arg_list =~ s/\s*//gi;

	# 引数リストが空になるまで分解
	while ($arg_list ne '') {
		# オペランドサイズ？
		if    (
			$arg_list =~ /^($g_regex_opsize)/i
		&&	# 許容する直前のステート
			(	$state eq 'label'
			||	$state eq 'register'
			||	$state eq 'number'
			||	$state eq ')'
			)
		) {
			$arg_list = $';
			my $opsize = $1;
			$arg .= $opsize;
			$state = 'opsize';
		}
		# スケール？
		elsif (
			$arg_list =~ /^($g_regex_register_scale)/i
		&&	# 許容する直前のステート
			(	$state eq 'register'
			||	$state eq 'opsize'
			)
		) {
			$arg_list = $';
			my $scale = $1;
			$arg .= $scale;
			$state = 'scale';
		}
		# レジスタ？
		elsif ($arg_list =~ /^($g_regex_register{$asm_mode}{'all'})/i) {
			$arg_list = $';
			my $register = $1;

			# ここで modify_register したくなるが、GAS レジスタの % が除去されると
			# レジスタと同名のラベルと区別が付かなくなってしまう。
			# modify_register 適用は最後に行う。

			$arg .= $register;
			$state = 'register';
		}
		# ビットフィールド？
		elsif ($arg_list =~ /^($g_regex_bitfield)/i) {
			$arg_list = $';
			my $bitfield = $1;
			$arg .= modify_bitfield($bitfield, $asm_mode);
			$state = 'bitfield';
		}
		# 数字？
		elsif ($arg_list =~ /^($g_regex_number)/i) {
			$arg_list = $';
			my $number = $1;
			$arg .= $number;
			$state = 'number';
		}
		# 演算子？
		elsif ($arg_list =~ /^($g_regex_operator{$asm_mode})/i) {
			$arg_list = $';
			my $operator = $1;
			$arg .= $operator;
			$state = 'operator';
		}
		# ローカルラベル？
		#	HAS の場合ローカルラベルに含まれる @ が項の境界と見なされてしまうので、
		#	ここでローカルラベル全体を認識して取り除く。
		elsif (
			$arg_list =~ /^($g_regex_ref_local_label{$asm_mode})/i
		) {
			$arg_list = $';
			my $local_label = $1;
			$arg .= $local_label;
			$state = 'local_label';
		}
		# オペランドサイズを含んだラベル（またはシンボル）？
		#	オペランドサイズを含まずラベルのみにマッチさせるのは難しい。
		#	ここではオペランドサイズ混みでマッチしたのち、オペランドサイズを
		#	分離する方法で実装している。
		elsif ($arg_list =~ /^($g_regex_label_and_symbol$g_regex_opsize?)/i) {
			$arg_list = $';
			my $label_with_opsize = $1;

			# ラベルとオペランドサイズに分解し、ラベル部のみ置換
			if ($label_with_opsize =~ /(.*)($g_regex_opsize)/i) {
				my $label	= $1;
				my $opsize	= $2;
				$arg .= symbol_db_translate($label, $asm_mode) . $opsize;
				$state = 'opsize';
			} else {
				$arg .= symbol_db_translate($label_with_opsize, $asm_mode);
				$state = 'label';
			}
		}
		# 文字列リテラル
		elsif (
			$arg_list =~ /^($g_regex_string_literal)/i
		&&	# 許容する直前のステート
			(	$state eq ''
			||	$state eq ','
			)
		) {
			$arg_list = $';
			my $string_literal = $1;
			$arg .= $string_literal;
			$state = 'string_literal';
		}
		# 項の境界、または終点？
		#	括弧
		#	即値の \#
		#	MIT syntax で出現する \@
		#	カンマ
		elsif ($arg_list =~ /^([\(\)\{\}\[\]\#\@,]|$)/i) {
			$arg_list = $';
			my $char = $1;
			$state = $char;

			# カンマ？
			if ($char eq ',') {
				# 最下段にいるなら引数境界と見なす
				my $n_stack = @a_stack;
				if ($n_stack == 0) {
					# 引数分解結果を push
					push(@a_split_arg, $arg);
					$arg = '';
				} else {
					$arg .= $char;
				}
			} else {
				$arg .= $char;

				# 小括弧開く？
				if    ($char eq '(') {
					push(@a_stack, $char);
				}
				# 小括弧閉じる？
				elsif ($char eq ')') {
					if (pop(@a_stack) ne '(') {
						die("$g_src_location: ERROR: split_and_modify_arg_list failed to parse [$arg_list].\n");
					}
				}
				# 中括弧開く？
				elsif ($char eq '{') {
					push(@a_stack, $char);
				}
				# 中括弧閉じる？
				elsif ($char eq '}') {
					if (pop(@a_stack) ne '{') {
						die("$g_src_location: ERROR: split_and_modify_arg_list failed to parse [$arg_list].\n");
					}
				}
				# 大括弧開く？
				elsif ($char eq '[') {
					push(@a_stack, $char);
				}
				# 大括弧閉じる？
				elsif ($char eq ']') {
					if (pop(@a_stack) ne '[') {
						die("$g_src_location: ERROR: split_and_modify_arg_list failed to parse [$arg_list].\n");
					}
				}
				# 上記以外
				else {
					# 何も行わない
				}
			}
		}
		# GAS のマクロ引数展開
		#	GAS では特殊文字として \ を使うが、HAS では不要。除去する。
		elsif (
			$asm_mode eq 'gas'
		&&	$arg_list =~ /^\\/i
		) {
			$arg_list = $';
			$arg .= '';
		}
		# 上記以外
		else {
			# ここにたどり着くことはない
			die("$g_src_location: ERROR: unknown arg_list $arg_list");
		}
	}

	# 引数分解結果を push
	push(@a_split_arg, $arg);
# print "split_and_modify_arg_list [$orig] -> [" . join(" / ", @a_split_arg) . "]\n";

	return @a_split_arg;
}


#------------------------------------------------------------------------------
#	引数リストを分解し、スペースを除去する
#
#	[parameters]
#		・$arg_list
#			引数リスト
#
#	[return]
#		引数配列
#------------------------------------------------------------------------------
sub split_and_strip_arg_list {
	my (
		$arg_list
	) = @_;

	# 行末コメントとスペースを除去
	$arg_list =~ s/$g_regex_line_end_comment//gi;
	$arg_list =~ s/\s*//gi;

	# 引数リストを配列に分解
	return split(',', $arg_list);
}


#------------------------------------------------------------------------------
#	string 文字列を dc.b ダンプに変換する
#
#	[parameters]
#		・$string
#			文字列
#
#	[return]
#		変換結果（末端に 0x00 が付加される）
#------------------------------------------------------------------------------
sub convert_string_to_dump {
	my ($string) = @_;
	my $dump = convert_ascii_to_dump($string) . "\n";
	$dump .= '	.dc.b $00';

	return $dump;
}


#------------------------------------------------------------------------------
#	ascii 文字列を dc.b ダンプに変換する
#
#	[parameters]
#		・$string
#			文字列
#
#	[return]
#		変換結果
#------------------------------------------------------------------------------
sub convert_ascii_to_dump {
	my ($string) = @_;
	my $dump;

	my @decoded = decode_escape_sequence($string);
	my $n = @decoded;
	my $n_per_line = 8;
	for (my $i = 0; $i < $n; $i += $n_per_line) {
		my $begin = $i;
		my $end   = ($i + $n_per_line < $n)? $i + $n_per_line: $n;
		if ($i != 0) {
			$dump .= "\n";
		}
		$dump .= '	.dc.b ';
		for (my $j = $begin; $j < $end; $j++) {
			if ($j != $begin) { $dump .= ','; }
			$dump .= $decoded[$j];
		}
	}

	return $dump;
}


#------------------------------------------------------------------------------
#	エスケープシーケンスされた文字列のデコード
#
#	[parameters]
#		・$string
#			文字列
#
#	[return]
#		変換結果 ($%02x 形式文字列) の配列
#------------------------------------------------------------------------------
sub decode_escape_sequence {
	my ($string) = @_;

	# 1 文字単位に分解
	my @chars = split('', $string);
	my $n = @chars;

	# デコード
	my @decoded;
	for (my $i = 0; $i < $n; $i++) {
		my $char = $chars[$i];
		if ($char eq '\\') {
			my $next_char = $chars[$i + 1];
			# 一般的なエスケープシーケンス
			if    ($next_char eq 'a') { push(@decoded, '$07'); $i += 1; }
			elsif ($next_char eq 'b') { push(@decoded, '$08'); $i += 1; }
			elsif ($next_char eq 't') { push(@decoded, '$09'); $i += 1; }
			elsif ($next_char eq 'n') { push(@decoded, '$0a'); $i += 1; }
			elsif ($next_char eq 'v') { push(@decoded, '$0b'); $i += 1; }
			elsif ($next_char eq 'f') { push(@decoded, '$0c'); $i += 1; }
			elsif ($next_char eq 'r') { push(@decoded, '$0d'); $i += 1; }
			# 3 桁 8 進数エンコード
			elsif (ord('0') <= ord($next_char) && ord($next_char) <= ord('9')) {
				push(@decoded, sprintf('$%02x', oct($next_char . $chars[$i + 2] . $chars[$i + 3])));
				$i += 3;
			}
			# その他の場合は変更せず出力
			else {
				push(@decoded, sprintf('$%02x', ord($next_char))); $i += 1;
			}
		} else {
			push(@decoded, sprintf('$%02x', ord($char)));
		}
	}

	return @decoded;
}


#------------------------------------------------------------------------------
#	桁数の計算
#
#	[parameters]
#		・$string
#			文字列
#
#	[return]
#		桁数
#------------------------------------------------------------------------------
sub calc_columns {
	my ($string) = @_;

	my $columns = 0;

	my @chars = split('', $string);
	foreach my $char (@chars) {
		if    ($char eq '	') {
			$columns = ($columns & ~7) + 8;
		}
		elsif ($char eq "\n") {
			$columns = 0;
		} else {
			$columns++;
		}
	}

	return $columns;
}


#------------------------------------------------------------------------------
#	文字列を分割する
#
#	[parameters]
#		・$string
#			文字列
#
#		・$max_len
#			許容する文字列長
#
#	[return]
#		分割された文字列
#------------------------------------------------------------------------------
sub split_string {
	my ($string, $max_len) = @_;

	my @a_part;
	{
		my @a_char = split('', $string);
		my $num_chars = @a_char;
		my $part = '';
		my $part_len = 0;
		my $sjis = 0;

		# 元の文字列を 1 文字ずつ処理するループ
		for (my $i = 0; $i < $num_chars; $i++) {
			my $char = $a_char[$i];
			my $char_code = ord($char);
			$part .= $char;
			$part_len++;

			if ($sjis == 0) {
				# sjis の 1 バイト目？
				if (0x81 <= $char_code  &&  $char_code <= 0x9f
				||	0xe0 <= $char_code  &&  $char_code <= 0xef
				) {
					$sjis = 1;
				}
			} else {
				# sjis の 2 バイト目？
				if (0x40 <= $char_code  &&  $char_code <= 0x7e
				||	0x80 <= $char_code  &&  $char_code <= 0xfc
				) {
					$sjis = 0;
				}
			}

			# 許容する文字列長を超えていて、かつ sjis 多バイト文字の途中でないなら
			if ($part_len > $max_len  &&  $sjis == 0) {
				push(@a_part, $part . "\n");
				$part = '';
				$part_len = 0;
			}
		}

		if ($part_len != 0) {
			push(@a_part, $part);
		}
	}

	return @a_part;
}


#------------------------------------------------------------------------------
#	シンボルデータベースにシンボル登録
#
#	[parameters]
#		・$key
#			シンボル
#------------------------------------------------------------------------------
sub symbol_db_register_symbol {
	my (
		$key
	) = @_;
	$g_symbol_db{'stack'}[$g_symbol_db{'depth'}]{$key} = $key;
	if (DEBUG) {
		print "symbol_db_register_symbol : $key\n";
	}
}


#------------------------------------------------------------------------------
#	シンボルデータベースにラベル置換ルールを登録
#
#	[parameters]
#		・$key
#			ラベル置換元
#
#		・$value
#			ラベル置換先
#------------------------------------------------------------------------------
sub symbol_db_register_label {
	my (
		$key,
		$value
	) = @_;
	$g_symbol_db{'stack'}[$g_symbol_db{'depth'}]{$key} = $value;
	if (DEBUG) {
		print "symbol_db_register_label : $key -> $value\n";
	}
}


#------------------------------------------------------------------------------
#	シンボルデータベースのラベル置換ルールに従い置換
#
#	[parameters]
#		・$key
#			ラベル置換元
#	
#		・$asm_mode
#			アセンブラモード（'gas' または 'has'）
#
#	[return]
#		ラベル置換先
#------------------------------------------------------------------------------
sub symbol_db_translate {
	my (
		$key,
		$asm_mode
	) = @_;

	# 置換ルールに登録されているか？
	for (my $depth = $g_symbol_db{'depth'}; $depth >= 0; $depth--) {
		if (exists($g_symbol_db{'stack'}[$depth]{$key})) {
			return $g_symbol_db{'stack'}[$depth]{$key};
		}
	}

	# 外部ラベルの修正
	return modify_label($key, $asm_mode);
}


#------------------------------------------------------------------------------
#	シンボルデータベースにラベルまたはシンボルが登録されているか確認
#
#	[parameters]
#		・$key
#			ラベルまたはシンボル
#	
#	[return]
#		・0
#			登録なし
#
#		・1
#			登録あり
#------------------------------------------------------------------------------
sub symbol_db_exists {
	my (
		$key
	) = @_;
	for (my $depth = $g_symbol_db{'depth'}; $depth >= 0; $depth--) {
		if (exists($g_symbol_db{'stack'}[$depth]{$key})) {
			return 1;
		}
	}
	return 0;
}


#------------------------------------------------------------------------------
#	シンボルデータベースのスタックを 1 段深くする
#
#	[parameters]
#		なし
#	
#	[return]
#		なし
#------------------------------------------------------------------------------
sub symbol_db_inc_depth {
	$g_symbol_db{'depth'}++;
	push(@{$g_symbol_db{'stack'}}, {});
	if (DEBUG) {
		print "symbol_db_inc_depth\n";
	}
}


#------------------------------------------------------------------------------
#	シンボルデータベースのスタックを 1 段浅くする
#
#	[parameters]
#		なし
#	
#	[return]
#		なし
#------------------------------------------------------------------------------
sub symbol_db_dec_depth {
	if ($g_symbol_db{'depth'} == 0) {
		die("$g_src_location: ERROR: symbol_db_dec_depth failed.");
	}
	pop(@{$g_symbol_db{'stack'}});
	$g_symbol_db{'depth'}--;
	if (DEBUG) {
		print "symbol_db_dec_depth\n";
	}
}


